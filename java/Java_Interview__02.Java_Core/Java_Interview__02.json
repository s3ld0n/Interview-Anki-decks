{
    "__type__": "Deck", 
    "children": [], 
    "crowdanki_uuid": "ef2b7b00-a69a-11ea-af9e-005056c00008", 
    "deck_config_uuid": "b56b2fc1-5b76-11e9-b461-005056c00008", 
    "deck_configurations": [
        {
            "__type__": "DeckConfig", 
            "autoplay": true, 
            "crowdanki_uuid": "b56b2fc1-5b76-11e9-b461-005056c00008", 
            "dyn": false, 
            "lapse": {
                "delays": [
                    30, 
                    1440
                ], 
                "leechAction": 1, 
                "leechFails": 8, 
                "minInt": 1, 
                "mult": 0.2
            }, 
            "maxTaken": 180, 
            "name": "AnKing", 
            "new": {
                "bury": false, 
                "delays": [
                    25, 
                    1440
                ], 
                "initialFactor": 2500, 
                "ints": [
                    3, 
                    3, 
                    7
                ], 
                "order": 1, 
                "perDay": 30, 
                "separate": true
            }, 
            "replayq": true, 
            "rev": {
                "bury": false, 
                "ease4": 1.5, 
                "fuzz": 0.05, 
                "ivlFct": 1.0, 
                "maxIvl": 120, 
                "minSpace": 1, 
                "perDay": 9999
            }, 
            "timer": 0
        }
    ], 
    "desc": "", 
    "dyn": 0, 
    "extendNew": 432, 
    "extendRev": 50, 
    "media_files": [
        "paste-46226733006851.png"
    ], 
    "mid": 1539853229554, 
    "name": "Java Interview::02.Java Core", 
    "note_models": [
        {
            "__type__": "NoteModel", 
            "crowdanki_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "css": ".card {\n font-familiy: arial;\n font-size: 20px;\n text-align: center;\n color: black;\n background-color: white;\n}", 
            "flds": [
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Front", 
                    "ord": 0, 
                    "rtl": false, 
                    "size": 20, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Back", 
                    "ord": 1, 
                    "rtl": false, 
                    "size": 20, 
                    "sticky": false
                }
            ], 
            "latexPost": "\\end{document}", 
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n", 
            "name": "Basic", 
            "req": [
                [
                    0, 
                    "all", 
                    [
                        0
                    ]
                ]
            ], 
            "sortf": 0, 
            "tags": [], 
            "tmpls": [
                {
                    "afmt": "{{FrontSide}}\n\n<hr id=answer>\n\n{{Back}}", 
                    "bafmt": "", 
                    "bfont": "Arial", 
                    "bqfmt": "", 
                    "bsize": 12, 
                    "did": null, 
                    "name": "Card 1", 
                    "ord": 0, 
                    "qfmt": "{{Front}}"
                }
            ], 
            "type": 0, 
            "vers": []
        }, 
        {
            "__type__": "NoteModel", 
            "crowdanki_uuid": "ef2c1764-a69a-11ea-993c-005056c00008", 
            "css": ".card {\n font-family: arial;\n font-size: 20px;\n text-align: left;\n color: black;\n background-color: white;\n}\n\n.cloze {\n font-family: Dejavu Sans Mono;\n color: green;\n}\n.nightMode .cloze {\n color: lightblue;\n}", 
            "flds": [
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text", 
                    "ord": 0, 
                    "rtl": false, 
                    "size": 20, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Extra", 
                    "ord": 1, 
                    "rtl": false, 
                    "size": 20, 
                    "sticky": false
                }
            ], 
            "latexPost": "\\end{document}", 
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n", 
            "name": "Cloze", 
            "sortf": 0, 
            "tags": [], 
            "tmpls": [
                {
                    "afmt": "{{cloze:Text}}<br>\n{{Extra}}", 
                    "bafmt": "", 
                    "bqfmt": "", 
                    "did": null, 
                    "name": "Cloze", 
                    "ord": 0, 
                    "qfmt": "{{cloze:Text}}"
                }
            ], 
            "type": 1, 
            "vers": []
        }, 
        {
            "__type__": "NoteModel", 
            "crowdanki_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "css": "/* general card style */\n\nhtml {\n  /* scrollbar always visible in order to prevent shift when revealing answer*/\n  overflow-y: scroll;\n}\n\n.card {\n  font-family: \"Helvetica LT Std\", Helvetica, Arial, Sans;\n  font-size: 150%;\n  text-align: center;\n  color: black;\n  background-color: white;\n}\n\n/* general layout */\n\n.text {\n  /* center left-aligned text on card */\n  display: inline-block;\n  align: center;\n  text-align: left;\n  margin: auto;\n  max-width: 40em;\n}\n\n.hidden {\n  /* guarantees a consistent width across front and back */\n  font-weight: bold;\n  display: block;\n  line-height:0;\n  height: 0;\n  overflow: hidden;\n  visibility: hidden;\n}\n\n.title {\n  font-weight: bold;\n  font-size: 1.1em;\n  margin-bottom: 1em;\n  text-align: center;\n}\n\n/* clozes */\n\n.cloze {\n  /* regular cloze deletion */\n  font-weight: bold;\n  color: #0048FF;\n}\n\n/* original text reveal hint */\n\n.fullhint a {\n  color: #0048FF;\n}\n\n.card21 .fullhint{\n  /* no need to display hint on last card */\n  display:none;\n}\n\n/* additional fields */\n\n.extra{\n  margin-top: 0.5em;\n  margin: auto;\n  max-width: 40em;\n}\n\n.extra-entry{\n  margin-top: 0.8em;\n  font-size: 0.9em;\n  text-align:left;\n}\n\n.extra-descr{\n  margin-bottom: 0.2em;\n  font-weight: bold;\n  font-size: 1em;\n}", 
            "flds": [
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Original", 
                    "ord": 0, 
                    "rtl": false, 
                    "size": 20, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Title", 
                    "ord": 1, 
                    "rtl": false, 
                    "size": 20, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Remarks", 
                    "ord": 2, 
                    "rtl": false, 
                    "size": 20, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Sources", 
                    "ord": 3, 
                    "rtl": false, 
                    "size": 20, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Settings", 
                    "ord": 4, 
                    "rtl": false, 
                    "size": 20, 
                    "sticky": true
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text1", 
                    "ord": 5, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text2", 
                    "ord": 6, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text3", 
                    "ord": 7, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text4", 
                    "ord": 8, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text5", 
                    "ord": 9, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text6", 
                    "ord": 10, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text7", 
                    "ord": 11, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text8", 
                    "ord": 12, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text9", 
                    "ord": 13, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text10", 
                    "ord": 14, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text11", 
                    "ord": 15, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text12", 
                    "ord": 16, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text13", 
                    "ord": 17, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text14", 
                    "ord": 18, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text15", 
                    "ord": 19, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text16", 
                    "ord": 20, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text17", 
                    "ord": 21, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text18", 
                    "ord": 22, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text19", 
                    "ord": 23, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Text20", 
                    "ord": 24, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }, 
                {
                    "font": "Arial", 
                    "media": [], 
                    "name": "Full", 
                    "ord": 25, 
                    "rtl": false, 
                    "size": 12, 
                    "sticky": false
                }
            ], 
            "latexPost": "\\end{document}", 
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n", 
            "name": "Cloze (overlapping)", 
            "sortf": 1, 
            "tags": [], 
            "tmpls": [
                {
                    "afmt": "<div class=\"back\">\n  {{#Title}}<div class=\"title\">{{Title}}</div>{{/Title}}\n  <div class=\"text\">\n    {{cloze:Text1}}\n    {{cloze:Text2}}\n    {{cloze:Text3}}\n    {{cloze:Text4}}\n    {{cloze:Text5}}\n    {{cloze:Text6}}\n    {{cloze:Text7}}\n    {{cloze:Text8}}\n    {{cloze:Text9}}\n    {{cloze:Text10}}\n    {{cloze:Text11}}\n    {{cloze:Text12}}\n    {{cloze:Text13}}\n    {{cloze:Text14}}\n    {{cloze:Text15}}\n    {{cloze:Text16}}\n    {{cloze:Text17}}\n    {{cloze:Text18}}\n    {{cloze:Text19}}\n    {{cloze:Text20}}\n    {{cloze:Full}}\n    <div class=\"hidden\">{{Original}}</div>\n  </div>\n  <div class=\"extra\"><hr></div>\n  <div class=\"text\"><div class=\"fullhint\">{{hint:Original}}</div></div>\n  <div class=\"extra\">\n    {{#Remarks}}\n    <div class=\"extra-entry\">\n      <div class=\"extra-descr\">Remarks</div><div>{{Remarks}}</div>\n    </div>\n    {{/Remarks}}\n    {{#Sources}}\n    <div class=\"extra-entry\">\n      <div class=\"extra-descr\">Sources</div><div>{{Sources}}</div>\n    </div>\n    {{/Sources}}\n  </div>\n</div>\n<script>\n  // remove cloze syntax from revealed hint\n  var hint = document.querySelector('.fullhint>[id^=\"hint\"]')\n  var html = hint.innerHTML.replace(/\\[\\[oc(\\d+)::(.*?)(::(.*?))?\\]\\]/mg, \"$2\")\n  hint.innerHTML = html\n  // scroll to cloze\n  document.addEventListener('DOMContentLoaded', function() {\n    setTimeout(function(){\n      const cloze1 = document.getElementsByClassName(\"cloze\")[0];\n      const rect = cloze1.getBoundingClientRect();\n      const absTop = rect.top + window.pageYOffset;\n      const absBot = rect.bottom + window.pageYOffset;\n      if (absBot >= window.innerHeight) {\n        const height = rect.top - rect.bottom\n        const middle = absTop - (window.innerHeight/2) - (height/2);\n        window.scrollTo(0, middle);};\n    }, 1);\n  }, false);\n</script>", 
                    "bafmt": "", 
                    "bqfmt": "", 
                    "did": null, 
                    "name": "cloze-ol", 
                    "ord": 0, 
                    "qfmt": "<div class=\"front\">\n  {{#Title}}<div class=\"title\">{{Title}}</div>{{/Title}}\n  <div class=\"text\">\n    {{cloze:Text1}}\n    {{cloze:Text2}}\n    {{cloze:Text3}}\n    {{cloze:Text4}}\n    {{cloze:Text5}}\n    {{cloze:Text6}}\n    {{cloze:Text7}}\n    {{cloze:Text8}}\n    {{cloze:Text9}}\n    {{cloze:Text10}}\n    {{cloze:Text11}}\n    {{cloze:Text12}}\n    {{cloze:Text13}}\n    {{cloze:Text14}}\n    {{cloze:Text15}}\n    {{cloze:Text16}}\n    {{cloze:Text17}}\n    {{cloze:Text18}}\n    {{cloze:Text19}}\n    {{cloze:Text20}}\n    {{cloze:Full}}\n    <div class=\"hidden\">\n       <div>{{Original}}</div>\n    </div>\n  </div>\n</div>"
                }
            ], 
            "type": 1, 
            "vers": []
        }
    ], 
    "notes": [
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0029. Чем различаются <b>JRE</b>, <b>JVM</b> и <b>JDK</b>?", 
                "<div><b>JDK</b> - среда для разработки программ на Java, включающая в себя <b>JRE</b> - среду для обеспечения запуска Java программ, которая в свою очередь содержит JVM - интерпретатор кода Java программ.</div>"
            ], 
            "flags": 0, 
            "guid": "CV$1),O-i", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>private</li><li>default (package-private)</li><li>protected</li><li>public</li></ol></div>", 
                "<div><b><code class=\"myCodeClass\">0030. Какие существуют модификаторы доступа?</code></b></div>", 
                "<div>Последовательность модификаторов по возрастанию уровня открытости:&nbsp;<code class=\"myCodeClass\">private, default(package-private), protected, public.</code></div><div>Во время наследования возможно изменения модификаторов доступа в сторону большей видимости (для поддержания соответствия принципу подстановки Барбары Лискоy).</div>", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::private}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>private</li><li>{{c2::default (package-private)}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>default (package-private)</li><li>{{c3::protected}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>protected</li><li>{{c4::public}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::private}}</li><li>{{c21::default (package-private)}}</li><li>{{c21::protected}}</li><li>{{c21::public}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "D<:2CySw#~", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0032. Какими значениями инициализируются переменные по умолчанию?", 
                "<div><br /></div><div>&nbsp; &nbsp; Числа инициализируются <code class=\"myCodeClass\">0</code> или <code class=\"myCodeClass\">0.0</code>;</div><div>&nbsp; &nbsp; <code class=\"myCodeClass\">char</code> — <code class=\"myCodeClass\">\\u0000</code>;</div><div>&nbsp; &nbsp; <code class=\"myCodeClass\">boolean</code> — <code class=\"myCodeClass\">false</code>;</div><div>&nbsp; &nbsp; Объекты (в том числе <code class=\"myCodeClass\">String</code>) — <code class=\"myCodeClass\">null</code>.</div><div><br /></div>"
            ], 
            "flags": 0, 
            "guid": "K)dwcy5TIH", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0033. Что вы знаете о функции <code class=\"myCodeClass\">main()</code>?", 
                "Метод <code class=\"myCodeClass\">main()</code> — точка входа в программу. Может быть перегружен. Если метод отсутствует, то компиляция возможна, но если такой класс запустить как приложение будет получена ошибка <code class=\"myCodeClass\">`Error: Main method not found`</code>.<div><br /></div><div><center><table><tbody><tr><td><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\"><span style=\"color: #008000;font-weight: bold\">public</span> <span style=\"color: #008000; font-weight: bold\">static</span> <span style=\"color: #B00040\">void</span> <span style=\"color: #0000FF\">main</span><span style=\"color: #666666\">(</span>String<span style=\"color: #666666\">[]</span> args<span style=\"color: #666666\">)</span> <span style=\"color: #666666\">{}</span></pre></div></td></tr></tbody></table></center><br /></div>"
            ], 
            "flags": 0, 
            "guid": "szNuinH=d|", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0035. Что такое тернарный оператор выбора?", 
                "<div>Тернарный условный оператор <code class=\"myCodeClass\">?:</code> - оператор, которым можно заменить некоторые конструкции операторов&nbsp;if-then-else.</div><div><br /></div><div>Выражение записывается в следующей форме:</div><div><br /></div><div><center><table><tbody><tr><td><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">условие <span style=\"color: #666666\">?</span> выражение1 <span style=\"color: #666666\">:</span> выражение2\n</pre></div>\n</td></tr></tbody></table></center></div><div><br /></div><div>Если <code class=\"myCodeClass\"><b><i><font color=\"#00aa00\">условие</font></i></b></code> выполняется, то вычисляется <i><b><font color=\"#00aa00\">выражение1</font></b></i> и его результат становится результатом выполнения всего оператора. Если же <i><b><font color=\"#00aa00\">условие</font></b></i> равно <code class=\"myCodeClass\">false</code>, то вычисляется <b><i><font color=\"#00aa00\">выражение2</font></i></b> и его значение становится результатом работы оператора. Оба операнда <i><font color=\"#00aa00\"><b>выражение1</b></font></i> и <font color=\"#00aa00\"><i><b>выражение2</b></i></font> должны возвращать значение одинакового (или совместимого) типа.</div>"
            ], 
            "flags": 0, 
            "guid": "pOjU;g(8FH", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0092. Дайте определение понятию <b><i>«интерфейс»</i></b>.", 
                "<div>Интерфейс - спецификация класса, его основное предназначение - определять каким образом мы можем использовать класс, который его реализует.&nbsp;</div>"
            ], 
            "flags": 0, 
            "guid": "G!r6Ew_2Be", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>&nbsp; &nbsp; Абстрактный класс используется чтобы избежать написания повторяющегося кода, инструмент для частичной реализации поведения. Интерфейс&nbsp;используется&nbsp;для&nbsp;выражения семантики класса, контракт, описывающий возможности.</li><li>&nbsp; &nbsp; Абстрактный класс может иметь конструкторы, состояние и поведение, интерфейс - нет.</li><li>&nbsp; &nbsp; В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.</li><li>&nbsp; Интерфейсы могут реализоваться классами, которые не связаны друг с другом. Все классы, наследующие один и тот же абстрактный класс, имеют отношение \"is a\" по отношению к абстрактному классу.!</li><li>Абстрактный класс может иметь поля и методы с любыми модификаторами доступа.&nbsp;Все поля&nbsp;интерфейса&nbsp;- public static final, а&nbsp;методы &nbsp;неявно public abstract&nbsp;или (начиная с Java 8), static методы, default методы (с реализацией по-умолчанию).&nbsp;</li><li>&nbsp; &nbsp; Интерфейсы позволяют создавать структуры типов без иерархии.</li><li>Интерфейс полностью абстрактный и не может иметь экземпляров. Абстрактный класс также не может иметь экземпляров класса, но может быть вызван, если существует метод main().</li><li>&nbsp; &nbsp; Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность. Реализуя интерфейс, он расширяет собственную функциональность..</li></ol></div>", 
                "0093. Чем абстрактный класс отличается от интерфейса?", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::&nbsp; &nbsp; Абстрактный класс используется чтобы избежать написания повторяющегося кода, инструмент для частичной реализации поведения. Интерфейс&nbsp;используется&nbsp;для&nbsp;выражения семантики класса, контракт, описывающий возможности.}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>&nbsp; &nbsp; Абстрактный класс используется чтобы избежать написания повторяющегося кода, инструмент для частичной реализации поведения. Интерфейс&nbsp;используется&nbsp;для&nbsp;выражения семантики класса, контракт, описывающий возможности.</li><li>{{c2::&nbsp; &nbsp; Абстрактный класс может иметь конструкторы, состояние и поведение, интерфейс - нет.}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>&nbsp; &nbsp; Абстрактный класс может иметь конструкторы, состояние и поведение, интерфейс - нет.</li><li>{{c3::&nbsp; &nbsp; В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>&nbsp; &nbsp; В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.</li><li>{{c4::&nbsp; Интерфейсы могут реализоваться классами, которые не связаны друг с другом. Все классы, наследующие один и тот же абстрактный класс, имеют отношение \"is a\" по отношению к абстрактному классу.!}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>&nbsp; Интерфейсы могут реализоваться классами, которые не связаны друг с другом. Все классы, наследующие один и тот же абстрактный класс, имеют отношение \"is a\" по отношению к абстрактному классу.!</li><li>{{c5::Абстрактный класс может иметь поля и методы с любыми модификаторами доступа.&nbsp;Все поля&nbsp;интерфейса&nbsp;- public static final, а&nbsp;методы &nbsp;неявно public abstract&nbsp;или (начиная с Java 8), static методы, default методы (с реализацией по-умолчанию).&nbsp;}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>Абстрактный класс может иметь поля и методы с любыми модификаторами доступа.&nbsp;Все поля&nbsp;интерфейса&nbsp;- public static final, а&nbsp;методы &nbsp;неявно public abstract&nbsp;или (начиная с Java 8), static методы, default методы (с реализацией по-умолчанию).&nbsp;</li><li>{{c6::&nbsp; &nbsp; Интерфейсы позволяют создавать структуры типов без иерархии.}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>&nbsp; &nbsp; Интерфейсы позволяют создавать структуры типов без иерархии.</li><li>{{c7::Интерфейс полностью абстрактный и не может иметь экземпляров. Абстрактный класс также не может иметь экземпляров класса, но может быть вызван, если существует метод main().}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>Интерфейс полностью абстрактный и не может иметь экземпляров. Абстрактный класс также не может иметь экземпляров класса, но может быть вызван, если существует метод main().</li><li>{{c8::&nbsp; &nbsp; Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность. Реализуя интерфейс, он расширяет собственную функциональность..}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::&nbsp; &nbsp; Абстрактный класс используется чтобы избежать написания повторяющегося кода, инструмент для частичной реализации поведения. Интерфейс&nbsp;используется&nbsp;для&nbsp;выражения семантики класса, контракт, описывающий возможности.}}</li><li>{{c21::&nbsp; &nbsp; Абстрактный класс может иметь конструкторы, состояние и поведение, интерфейс - нет.}}</li><li>{{c21::&nbsp; &nbsp; В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.}}</li><li>{{c21::&nbsp; Интерфейсы могут реализоваться классами, которые не связаны друг с другом. Все классы, наследующие один и тот же абстрактный класс, имеют отношение \"is a\" по отношению к абстрактному классу.!}}</li><li>{{c21::Абстрактный класс может иметь поля и методы с любыми модификаторами доступа.&nbsp;Все поля&nbsp;интерфейса&nbsp;- public static final, а&nbsp;методы &nbsp;неявно public abstract&nbsp;или (начиная с Java 8), static методы, default методы (с реализацией по-умолчанию).&nbsp;}}</li><li>{{c21::&nbsp; &nbsp; Интерфейсы позволяют создавать структуры типов без иерархии.}}</li><li>{{c21::Интерфейс полностью абстрактный и не может иметь экземпляров. Абстрактный класс также не может иметь экземпляров класса, но может быть вызван, если существует метод main().}}</li><li>{{c21::&nbsp; &nbsp; Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность. Реализуя интерфейс, он расширяет собственную функциональность..}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "le:-v+ggh|", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0096. Почему в некоторых интерфейсах вообще не определяют методов?", 
                "Это так называемые <i>маркерные интерфейсы</i>. Они просто указывают что класс относится к определенному типу. Примером может послужить интерфейс <code class=\"myCodeClass\">Clonable</code>, который указывает на то, что класс поддерживает механизм клонирования."
            ], 
            "flags": 0, 
            "guid": "j.E-k?s0U)", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0097. Почему нельзя объявить метод интерфейса с модификатором <code class=\"myCodeClass\">final</code>?", 
                "В случае интерфейсов указание модификатора <code class=\"myCodeClass\">final</code> бессмысленно, т.к. все методы интерфейсов неявно объявляются как абстрактные, т.е. их невозможно выполнить, не реализовав где-то еще, а этого нельзя будет сделать, если у метода идентификатор <code class=\"myCodeClass\">final</code>."
            ], 
            "flags": 0, 
            "guid": "vWYEzfY;+;", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0098. Что имеет более высокий уровень абстракции - <b><i>класс, абстрактный класс</i></b> или <b><i>интерфейс</i></b>?", 
                "Интерфейс."
            ], 
            "flags": 0, 
            "guid": "d3{w%i)vL.", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ul><li>&nbsp; &nbsp; Внутри класса доступ к приватной переменной открыт без ограничений;</li><li>&nbsp; &nbsp; Вложенный класс имеет полный доступ ко всем (в том числе и приватным) членам содержащего его класса;</li><li>&nbsp; &nbsp; Доступ к приватным переменным извне может быть организован через отличные от приватных методы, которые предоставлены разработчиком класса. Например: getX(), setX().</li><li>&nbsp; &nbsp; Через механизм рефлексии (<code class=\"myCodeClass\"><b><i>Reflection API</i></b></code>):</li></ul><div><div></div></div></div>", 
                "<div><div>0099. Каким образом объект может получить доступ к члену класса объявленному как&nbsp;<code class=\"myCodeClass\">private</code>?</div></div>", 
                "<table><tbody><tr><td><div class=\"highlight\" style=\"background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: rgb(248, 248, 248); background-position: initial initial; background-repeat: initial initial; \"><pre style=\"line-height: 16px; \"><span style=\"color: rgb(0, 128, 0);font-weight: bold\">class</span> <span style=\"color: rgb(0, 0, 255); font-weight: bold; \">Victim</span> <span style=\"color: rgb(102, 102, 102); \">{</span> \n    <span style=\"color: rgb(0, 128, 0); font-weight: bold; \">private</span> <span style=\"color: rgb(176, 0, 64); \">int</span> field <span style=\"color: rgb(102, 102, 102); \">=</span> <span style=\"color: rgb(102, 102, 102); \">42;</span>\n<span style=\"color: rgb(102, 102, 102); \">}</span>\n<span style=\"color: rgb(64, 128, 128); font-style: italic; \">//...</span>\nVictim victim <span style=\"color: rgb(102, 102, 102); \">=</span> <span style=\"color: rgb(0, 128, 0); font-weight: bold; \">new</span> Victim<span style=\"color: rgb(102, 102, 102); \">();</span> \nField field <span style=\"color: rgb(102, 102, 102); \">=</span> Victim<span style=\"color: rgb(102, 102, 102); \">.</span><span style=\"color: rgb(125, 144, 41); \">class</span><span style=\"color: rgb(102, 102, 102); \">.</span><span style=\"color: rgb(125, 144, 41); \">getDeclaredField</span><span style=\"color: rgb(102, 102, 102); \">(</span><span style=\"color: rgb(186, 33, 33); \">\"field\"</span><span style=\"color: rgb(102, 102, 102); \">);</span> \nfield<span style=\"color: rgb(102, 102, 102); \">.</span><span style=\"color: rgb(125, 144, 41); \">setAccessible</span><span style=\"color: rgb(102, 102, 102); \">(</span><span style=\"color: rgb(0, 128, 0); font-weight: bold; \">true</span><span style=\"color: rgb(102, 102, 102); \">);</span> \n<span style=\"color: rgb(176, 0, 64); \">int</span> fieldValue <span style=\"color: rgb(102, 102, 102); \">=</span> <span style=\"color: rgb(102, 102, 102); \">(</span><span style=\"color: rgb(176, 0, 64); \">int</span><span style=\"color: rgb(102, 102, 102); \">)</span> field<span style=\"color: rgb(102, 102, 102); \">.</span><span style=\"color: rgb(125, 144, 41); \">get</span><span style=\"color: rgb(102, 102, 102); \">(</span>victim<span style=\"color: rgb(102, 102, 102); \">);</span>\n<span style=\"color: rgb(64, 128, 128); font-style: italic; \">//...</span>\n</pre></div></td></tr></tbody></table>", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::&nbsp; &nbsp; Внутри класса доступ к приватной переменной открыт без ограничений;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ul>", 
                "<ul><li>&nbsp; &nbsp; Внутри класса доступ к приватной переменной открыт без ограничений;</li><li>{{c2::&nbsp; &nbsp; Вложенный класс имеет полный доступ ко всем (в том числе и приватным) членам содержащего его класса;}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ul>", 
                "<ul><li>...</li><li>&nbsp; &nbsp; Вложенный класс имеет полный доступ ко всем (в том числе и приватным) членам содержащего его класса;</li><li>{{c3::&nbsp; &nbsp; Доступ к приватным переменным извне может быть организован через отличные от приватных методы, которые предоставлены разработчиком класса. Например: getX(), setX().}}</li><li>...</li><li>...</li><li>...</li></ul>", 
                "<ul><li>...</li><li>...</li><li>&nbsp; &nbsp; Доступ к приватным переменным извне может быть организован через отличные от приватных методы, которые предоставлены разработчиком класса. Например: getX(), setX().</li><li>{{c4::&nbsp; &nbsp; Через механизм рефлексии (}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>...</li><li>...</li><li>...</li><li>&nbsp; &nbsp; Через механизм рефлексии (</li><li>{{c5::Reflection API}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>...</li><li>...</li><li>...</li><li>Reflection API</li><li>{{c6::):}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::&nbsp; &nbsp; Внутри класса доступ к приватной переменной открыт без ограничений;}}</li><li>{{c21::&nbsp; &nbsp; Вложенный класс имеет полный доступ ко всем (в том числе и приватным) членам содержащего его класса;}}</li><li>{{c21::&nbsp; &nbsp; Доступ к приватным переменным извне может быть организован через отличные от приватных методы, которые предоставлены разработчиком класса. Например: getX(), setX().}}</li><li>{{c21::&nbsp; &nbsp; Через механизм рефлексии (}}</li><li>{{c21::Reflection API}}</li><li>{{c21::):}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "P9(cIM7ol=", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><br /></div><ul><li>&nbsp; &nbsp; Parent static block(s) → Child static block(s) → Grandchild static block(s)</li><li>&nbsp; &nbsp; → Parent non-static block(s) → Parent constructor →</li><li>&nbsp; &nbsp; → Child non-static block(s) → Child constructor →</li><li>&nbsp; &nbsp; → Grandchild non-static block(s) → Grandchild constructor</li></ul>", 
                "<div><br /></div><div>0100. Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?</div><div><br /></div>", 
                "<div>Сначала вызываются все статические блоки в очередности от первого статического блока корневого предка и выше по цепочке иерархии до статических блоков самого класса.</div><div><br /></div><div>Затем вызываются нестатические блоки инициализации корневого предка, конструктор корневого предка и так далее вплоть до нестатических блоков и конструктора самого класса.</div>", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::&nbsp; &nbsp; Parent static block(s) → Child static block(s) → Grandchild static block(s)}}</li><li>...</li><li>...</li><li>...</li></ul>", 
                "<ul><li>&nbsp; &nbsp; Parent static block(s) → Child static block(s) → Grandchild static block(s)</li><li>{{c2::&nbsp; &nbsp; → Parent non-static block(s) → Parent constructor →}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>...</li><li>&nbsp; &nbsp; → Parent non-static block(s) → Parent constructor →</li><li>{{c3::&nbsp; &nbsp; → Child non-static block(s) → Child constructor →}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>...</li><li>&nbsp; &nbsp; → Child non-static block(s) → Child constructor →</li><li>{{c4::&nbsp; &nbsp; → Grandchild non-static block(s) → Grandchild constructor}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::&nbsp; &nbsp; Parent static block(s) → Child static block(s) → Grandchild static block(s)}}</li><li>{{c21::&nbsp; &nbsp; → Parent non-static block(s) → Parent constructor →}}</li><li>{{c21::&nbsp; &nbsp; → Child non-static block(s) → Child constructor →}}</li><li>{{c21::&nbsp; &nbsp; → Grandchild non-static block(s) → Grandchild constructor}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "u30-!#vE3g", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>&nbsp; &nbsp; полям;</li><li>&nbsp; &nbsp; методам;</li><li>&nbsp; &nbsp; вложенным классам;</li><li>&nbsp; &nbsp; блокам инициализации</li><li>&nbsp; &nbsp; членам секции import.</li></ol></div>", 
                "<div>0102. К каким конструкциям Java применим модификатор&nbsp;<code class=\"myCodeClass\" style=\"background-color: rgb(217, 215, 231); \">static</code>?</div>", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::&nbsp; &nbsp; полям;}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>&nbsp; &nbsp; полям;</li><li>{{c2::&nbsp; &nbsp; методам;}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>&nbsp; &nbsp; методам;</li><li>{{c3::&nbsp; &nbsp; вложенным классам;}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>&nbsp; &nbsp; вложенным классам;</li><li>{{c4::&nbsp; &nbsp; блокам инициализации}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>&nbsp; &nbsp; блокам инициализации</li><li>{{c5::&nbsp; &nbsp; членам секции import.}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::&nbsp; &nbsp; полям;}}</li><li>{{c21::&nbsp; &nbsp; методам;}}</li><li>{{c21::&nbsp; &nbsp; вложенным классам;}}</li><li>{{c21::&nbsp; &nbsp; блокам инициализации}}</li><li>{{c21::&nbsp; &nbsp; членам секции import.}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "yPGUAgOmRM", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0102. Для чего в Java используются статические блоки инициализации?", 
                "Статические блоки инициализация используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов."
            ], 
            "flags": 0, 
            "guid": "ins+.UaaE", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>Если возникшее исключение - наследник&nbsp;:RuntimeException -&nbsp;для статических блоков инициализации будет выброшено&nbsp;java.lang.ExceptionInInitializerError;&nbsp;- для нестатических будет проброшено исключение-источник.</li><li>Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено java.lang.Error.&nbsp;</li><li>Частный случай: java.lang.ThreadDeath&nbsp;&nbsp;- смерть потока. В этом случае никакое исключение выброшено не будет.</li></ol></div>", 
                "<div><div>0104. Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?</div></div>", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::Если возникшее исключение - наследник&nbsp;:RuntimeException -&nbsp;для статических блоков инициализации будет выброшено&nbsp;java.lang.ExceptionInInitializerError;&nbsp;- для нестатических будет проброшено исключение-источник.}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>Если возникшее исключение - наследник&nbsp;:RuntimeException -&nbsp;для статических блоков инициализации будет выброшено&nbsp;java.lang.ExceptionInInitializerError;&nbsp;- для нестатических будет проброшено исключение-источник.</li><li>{{c2::Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено java.lang.Error.&nbsp;}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено java.lang.Error.&nbsp;</li><li>{{c3::Частный случай: java.lang.ThreadDeath&nbsp;&nbsp;- смерть потока. В этом случае никакое исключение выброшено не будет.}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::Если возникшее исключение - наследник&nbsp;:RuntimeException -&nbsp;для статических блоков инициализации будет выброшено&nbsp;java.lang.ExceptionInInitializerError;&nbsp;- для нестатических будет проброшено исключение-источник.}}</li><li>{{c21::Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено java.lang.Error.&nbsp;}}</li><li>{{c21::Частный случай: java.lang.ThreadDeath&nbsp;&nbsp;- смерть потока. В этом случае никакое исключение выброшено не будет.}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "u`jsn(syK!", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0105. Может ли статический метод быть перегружен?", 
                "<div>да. Всё работает точно так же как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.</div>"
            ], 
            "flags": 0, 
            "guid": "E6GyGdao]=", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0107. Могут ли нестатические методы перегрузить статические?", 
                "Да. Получится два разных метода. Статический будет принадлежать классу и будет доступен через его имя, а нестатический будет принадлежать конкретному объекту и доступен через вызов метода этого объекта."
            ], 
            "flags": 0, 
            "guid": "fML&2Vix$m", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0112. Как получить доступ к методам родительского класса из класса, где они переопределены?", 
                "С помощью ключевого слова <code class=\"myCodeClass\" style=\"background-color: rgb(228, 231, 236);\">super</code> мы можем обратиться к любому члену родительского класса - методу или полю, если они не определены с модификатором <code class=\"myCodeClass\" style=\"background-color: rgb(235, 233, 249);\">private</code>.<div><center><table><tbody><tr><td><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\"><span style=\"color: #008000;font-weight: bold\">super</span><span style=\"color: #666666\">.</span><span style=\"color: #7D9029\">method</span><span style=\"color: #666666\">();</span>\n</pre></div>\n</td></tr></tbody></table></center><br /></div>"
            ], 
            "flags": 0, 
            "guid": "vAm(/ZR;G<", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0113. Можно ли объявить метод абстрактным и статическим одновременно?", 
                "Нет. В таком случае компилятор выдаст ошибку: <code class=\"myCodeClass\" style=\"background-color: rgb(235, 233, 249);\">\"Illegal combination of modifiers: ‘abstract’ and ‘static’\"</code>. Модификатор <code class=\"myCodeClass\">abstract</code> говорит, что метод будет реализован в другом классе, а <code class=\"myCodeClass\">static</code> наоборот указывает, что этот метод будет доступен по имени класса."
            ], 
            "flags": 0, 
            "guid": "hB:o_1*Za:", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0114. В чем разница между членом экземпляра класса и статическим членом класса?", 
                "<div>Модификатор <code class=\"myCodeClass\" style=\"background-color: rgb(235, 233, 249);\">static</code> говорит о том, что данный метод или поле принадлежат самому классу и доступ к ним возможен даже без создания экземпляра класса.&nbsp;</div><div>В отличии от статических, поля экземпляра класса принадлежат конкретному объекту и могут иметь разные значения для каждого. Вызов метода экземпляра возможен только после предварительного создания объекта класса.</div>"
            ], 
            "flags": 0, 
            "guid": "L$gkAnPcO>", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ul><li>Обычный класс (top level), может так же быть абстрактным или final</li><li>Интерфейс</li><li>Перечисление (Enum)</li><li>Вложенный класс</li></ul>", 
                "<div><div>0118. Какие ссылочные типы бывают в java?</div></div>", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::Обычный класс (top level), может так же быть абстрактным или final}}</li><li>...</li><li>...</li><li>...</li></ul>", 
                "<ul><li>Обычный класс (top level), может так же быть абстрактным или final</li><li>{{c2::Интерфейс}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>...</li><li>Интерфейс</li><li>{{c3::Перечисление (Enum)}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>...</li><li>Перечисление (Enum)</li><li>{{c4::Вложенный класс}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::Обычный класс (top level), может так же быть абстрактным или final}}</li><li>{{c21::Интерфейс}}</li><li>{{c21::Перечисление (Enum)}}</li><li>{{c21::Вложенный класс}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "O-A^og9>}n", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0128. Что такое «<b><i>статический класс</i></b>»?", 
                "Это внутренний класс, объявленный с использованием ключевого слова <code class=\"myCodeClass\" style=\"background-color: rgb(235, 233, 249);\">static</code>. К классам верхнего уровня модификатор <code class=\"myCodeClass\" style=\"background-color: rgb(235, 233, 249);\">static</code> неприменим."
            ], 
            "flags": 0, 
            "guid": "u@1r-`5T>s", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>&nbsp; &nbsp; все внутренние классы могут обращаться ко всем членам обрамляющего класса, в том числе и приватным.</li><li>&nbsp; &nbsp; Для создания объекта статического внутреннего класса объект внешнего класса не требуется.</li><li>&nbsp; &nbsp; Из объекта статического внутреннего класса нельзя обращаться к не статическим членам обрамляющего класса напрямую, а только через ссылку на экземпляр внешнего класса.</li><li>&nbsp; &nbsp; Обычные внутренние классы не могут содержать статических методов, блоков инициализации и классов. Статические внутренние классы - могут.</li><li>&nbsp; &nbsp; В объекте обычного внутреннего класса хранится ссылка на объект внешнего класса. Внутри статического такой ссылки нет. Доступ к экземпляру обрамляющего класса осуществляется через указание .this&nbsp;после его имени. Например:&nbsp;Outer.this</li></ol></div>", 
                "0129.&nbsp;Какие существуют особенности использования внутренних классов: статических и не-статических? В чем заключается разница между ними?", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::&nbsp; &nbsp; все внутренние классы могут обращаться ко всем членам обрамляющего класса, в том числе и приватным.}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>&nbsp; &nbsp; все внутренние классы могут обращаться ко всем членам обрамляющего класса, в том числе и приватным.</li><li>{{c2::&nbsp; &nbsp; Для создания объекта статического внутреннего класса объект внешнего класса не требуется.}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>&nbsp; &nbsp; Для создания объекта статического внутреннего класса объект внешнего класса не требуется.</li><li>{{c3::&nbsp; &nbsp; Из объекта статического внутреннего класса нельзя обращаться к не статическим членам обрамляющего класса напрямую, а только через ссылку на экземпляр внешнего класса.}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>&nbsp; &nbsp; Из объекта статического внутреннего класса нельзя обращаться к не статическим членам обрамляющего класса напрямую, а только через ссылку на экземпляр внешнего класса.</li><li>{{c4::&nbsp; &nbsp; Обычные внутренние классы не могут содержать статических методов, блоков инициализации и классов. Статические внутренние классы - могут.}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>&nbsp; &nbsp; Обычные внутренние классы не могут содержать статических методов, блоков инициализации и классов. Статические внутренние классы - могут.</li><li>{{c5::&nbsp; &nbsp; В объекте обычного внутреннего класса хранится ссылка на объект внешнего класса. Внутри статического такой ссылки нет. Доступ к экземпляру обрамляющего класса осуществляется через указание .this&nbsp;после его имени. Например:&nbsp;Outer.this}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::&nbsp; &nbsp; все внутренние классы могут обращаться ко всем членам обрамляющего класса, в том числе и приватным.}}</li><li>{{c21::&nbsp; &nbsp; Для создания объекта статического внутреннего класса объект внешнего класса не требуется.}}</li><li>{{c21::&nbsp; &nbsp; Из объекта статического внутреннего класса нельзя обращаться к не статическим членам обрамляющего класса напрямую, а только через ссылку на экземпляр внешнего класса.}}</li><li>{{c21::&nbsp; &nbsp; Обычные внутренние классы не могут содержать статических методов, блоков инициализации и классов. Статические внутренние классы - могут.}}</li><li>{{c21::&nbsp; &nbsp; В объекте обычного внутреннего класса хранится ссылка на объект внешнего класса. Внутри статического такой ссылки нет. Доступ к экземпляру обрамляющего класса осуществляется через указание .this&nbsp;после его имени. Например:&nbsp;Outer.this}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "h&0#d;/aBW", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0130. Что такое <b><i>«локальный класс»</i></b>?", 
                "<div><b>Local inner class</b> (Локальный класс) - это внутренний класс, который может быть объявлен в любом блоке, в котором разрешается объявлять переменные.<br />(упомянуть про наличие имени, можно ли многократно использовать, про ссылку на внешний экземпляр)</div>"
            ], 
            "flags": 0, 
            "guid": "G&9@vLwB`L", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0132. Что такое <b><i>«анонимный класс»</i></b>?", 
                "<div>Это вложенный локальный класс без имени, который разрешено декларировать в любом месте внешнего класса, разрешающем размещение выражений. Создание экземпляра анонимного класса происходит одновременно с его объявлением.&nbsp;</div>"
            ], 
            "flags": 0, 
            "guid": "wzB#;>_ljW", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>Статический внутренний класс имеет прямой доступ только к статическим полям обрамляющего класса.</li><li>Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую.&nbsp;</li><li>В случае, если у внутреннего класса уже существует поле с таким же литералом, то обращаться к такому полю следует через ссылку на его экземляр. Например: Outer.this.field.</li></ol></div>", 
                "<div>0135. Каким образом из внутреннего класса получить доступ к полю внешнего класса?</div>", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::Статический внутренний класс имеет прямой доступ только к статическим полям обрамляющего класса.}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>Статический внутренний класс имеет прямой доступ только к статическим полям обрамляющего класса.</li><li>{{c2::Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую.&nbsp;}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую.&nbsp;</li><li>{{c3::В случае, если у внутреннего класса уже существует поле с таким же литералом, то обращаться к такому полю следует через ссылку на его экземляр. Например: Outer.this.field.}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::Статический внутренний класс имеет прямой доступ только к статическим полям обрамляющего класса.}}</li><li>{{c21::Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую.&nbsp;}}</li><li>{{c21::В случае, если у внутреннего класса уже существует поле с таким же литералом, то обращаться к такому полю следует через ссылку на его экземляр. Например: Outer.this.field.}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "orl#x#:6}k", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div>0136_1. план ответа про оператор&nbsp;assert</div>", 
                "<ol><li>Определение</li><li>Польза при рефакторинге</li><li>Тестирование и релиз-версии</li><li>Не должны изменять поведение программы</li><li>Реализация в Java</li><li>Механизм работы</li></ol>"
            ], 
            "flags": 0, 
            "guid": "x)%$k2)2]y", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": [
                "marked"
            ]
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0141. план ответа про Heap&nbsp;память в Java", 
                "<div><ol type=\"1\" start=\"1\"><li>Что такое куча</li><li>Для чего используется</li><li>Пямять, выделяемая для создаваемых объектов</li><li>Отношение к GC</li><li>Доступ к объектам в куче</li></ol></div>"
            ], 
            "flags": 0, 
            "guid": "n.!K;8=By&", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": [
                "marked"
            ]
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0145. Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче?", 
                "Не совсем. Примитивное поле экземпляра класса хранится не в стеке, а в куче. Любой объект (всё, что явно или неявно создаётся при помощи оператора new) хранится в куче. Локальные переменные примитивного типа хранятся в стеке."
            ], 
            "flags": 0, 
            "guid": "sqqz?5@;4`", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0146. Каким образом передаются переменные в методы, по значению или по ссылке?", 
                "В Java параметры всегда передаются только по значению, что определяется как «скопировать значение и передать копию». С примитивами это будет копия содержимого. Со ссылками - тоже копия содержимого, т.е. копия ссылки. При этом внутренние члены ссылочных типов через такую копию изменить возможно, а вот саму ссылку, указывающую на экземпляр - нет."
            ], 
            "flags": 0, 
            "guid": "lp-o}E0*@G", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0025. Что такое <b>полиморфная переменная</b><b style=\"font-style: italic; \">?</b>", 
                "это переменная, которая может принимать значения разных типов"
            ], 
            "flags": 0, 
            "guid": "CgdoC!mg}q", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0036. Ключевая особенность полиморфизма", 
                "Использование объекта производного класса, при обращении к нему по ссылке типа базового класса.&nbsp;<div>А так же использование объекта класса реализующего некий интерфейс по ссылке типа этого интерфейса.</div>"
            ], 
            "flags": 0, 
            "guid": "B}{G16JkT2", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ul><li>могут вызывать только другие статические методы.</li><li>должны осуществлять доступ только к статическим переменным.</li><li>не могут ссылаться на члены типa this&nbsp;или super.</li></ul>", 
                "0115. Ограничения <code class=\"myCodeClass\" style=\"background-color: rgb(232, 232, 232);\">static</code> методов", 
                "", 
                "", 
                "0,1,0 | n,n,n,n", 
                "<ul><li>{{c1::могут вызывать только другие статические методы.}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>...</li><li>{{c2::должны осуществлять доступ только к статическим переменным.}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>...</li><li>{{c3::не могут ссылаться на члены типa this&nbsp;или super.}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::могут вызывать только другие статические методы.}}</li><li>{{c21::должны осуществлять доступ только к статическим переменным.}}</li><li>{{c21::не могут ссылаться на члены типa this&nbsp;или super.}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "ct4OmIHs:l", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0038. Что такое абстрактный метод", 
                "Метод помеченный ключевым словом&nbsp;<code class=\"myCodeClass\">abstract,</code>&nbsp;не имеет реализации (тела), должен быть реализован в потомках. Если в классе присутствует хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным."
            ], 
            "flags": 0, 
            "guid": "KH+YAa??H^", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0093_1. Как используются абстрактные классы и методы", 
                "Использование абстрактных классов и методов позволяет описать общее поведение для наследников, при этом можно частично или полностью его реализовать в самом абстрактном классе. Полезно объявить абстрактным класс, если он являет собой некую базовую сущность, объекты которой не нужно создавать."
            ], 
            "flags": 0, 
            "guid": "N2qzN2j[[y", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>&amp; &nbsp; &nbsp; Логическое AND (И);</li><li>&amp;&amp; &nbsp; Сокращённое AND;</li><li>I &nbsp; &nbsp; &nbsp;Логическое OR (ИЛИ);</li><li>II &nbsp; &nbsp; Сокращённое OR;</li><li>^ &nbsp; &nbsp; &nbsp;Логическое XOR (исключающее OR (ИЛИ));</li><li>! &nbsp; &nbsp; &nbsp;Логическое унарное NOT (НЕ);</li><li>&amp;= &nbsp; AND с присваиванием;</li><li>|= &nbsp; &nbsp;OR с присваиванием;</li><li>^= &nbsp; &nbsp;XOR с присваиванием;</li><li>== &nbsp; Равно;</li><li>!= &nbsp; &nbsp;Не равно;</li><li>?: &nbsp; &nbsp;Тернарный (троичный) условный оператор</li></ol></div>", 
                "0034. Какие логические операции и операторы вы знаете?", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::&amp; &nbsp; &nbsp; Логическое AND (И);}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>&amp; &nbsp; &nbsp; Логическое AND (И);</li><li>{{c2::&amp;&amp; &nbsp; Сокращённое AND;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>&amp;&amp; &nbsp; Сокращённое AND;</li><li>{{c3::I &nbsp; &nbsp; &nbsp;Логическое OR (ИЛИ);}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>I &nbsp; &nbsp; &nbsp;Логическое OR (ИЛИ);</li><li>{{c4::II &nbsp; &nbsp; Сокращённое OR;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>II &nbsp; &nbsp; Сокращённое OR;</li><li>{{c5::^ &nbsp; &nbsp; &nbsp;Логическое XOR (исключающее OR (ИЛИ));}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>^ &nbsp; &nbsp; &nbsp;Логическое XOR (исключающее OR (ИЛИ));</li><li>{{c6::! &nbsp; &nbsp; &nbsp;Логическое унарное NOT (НЕ);}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>! &nbsp; &nbsp; &nbsp;Логическое унарное NOT (НЕ);</li><li>{{c7::&amp;= &nbsp; AND с присваиванием;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>&amp;= &nbsp; AND с присваиванием;</li><li>{{c8::|= &nbsp; &nbsp;OR с присваиванием;}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>|= &nbsp; &nbsp;OR с присваиванием;</li><li>{{c9::^= &nbsp; &nbsp;XOR с присваиванием;}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>^= &nbsp; &nbsp;XOR с присваиванием;</li><li>{{c10::== &nbsp; Равно;}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>== &nbsp; Равно;</li><li>{{c11::!= &nbsp; &nbsp;Не равно;}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>!= &nbsp; &nbsp;Не равно;</li><li>{{c12::?: &nbsp; &nbsp;Тернарный (троичный) условный оператор}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::&amp; &nbsp; &nbsp; Логическое AND (И);}}</li><li>{{c21::&amp;&amp; &nbsp; Сокращённое AND;}}</li><li>{{c21::I &nbsp; &nbsp; &nbsp;Логическое OR (ИЛИ);}}</li><li>{{c21::II &nbsp; &nbsp; Сокращённое OR;}}</li><li>{{c21::^ &nbsp; &nbsp; &nbsp;Логическое XOR (исключающее OR (ИЛИ));}}</li><li>{{c21::! &nbsp; &nbsp; &nbsp;Логическое унарное NOT (НЕ);}}</li><li>{{c21::&amp;= &nbsp; AND с присваиванием;}}</li><li>{{c21::|= &nbsp; &nbsp;OR с присваиванием;}}</li><li>{{c21::^= &nbsp; &nbsp;XOR с присваиванием;}}</li><li>{{c21::== &nbsp; Равно;}}</li><li>{{c21::!= &nbsp; &nbsp;Не равно;}}</li><li>{{c21::?: &nbsp; &nbsp;Тернарный (троичный) условный оператор}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "n4}Akk+-|C", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>при объявлении</li><li>в статическом блоке инициализации</li><li>нестатическом блоке инициализации</li><li>конструкторе</li><li>статическом методе</li><li>нестатическом методе</li></ol></div>", 
                "0116. Где разрешена инициализация статических полей?", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::при объявлении}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>при объявлении</li><li>{{c2::в статическом блоке инициализации}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>в статическом блоке инициализации</li><li>{{c3::нестатическом блоке инициализации}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>нестатическом блоке инициализации</li><li>{{c4::конструкторе}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>конструкторе</li><li>{{c5::статическом методе}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>статическом методе</li><li>{{c6::нестатическом методе}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::при объявлении}}</li><li>{{c21::в статическом блоке инициализации}}</li><li>{{c21::нестатическом блоке инициализации}}</li><li>{{c21::конструкторе}}</li><li>{{c21::статическом методе}}</li><li>{{c21::нестатическом методе}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "E^z;+3ejOB", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>при объявлении</li><li>в нестатическом блоке инициализации</li><li>в конструкторе</li><li>в нестатическом методе</li></ol></div>", 
                "0117. Где разрешена инициализация нестатических полей?", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::при объявлении}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>при объявлении</li><li>{{c2::в нестатическом блоке инициализации}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>в нестатическом блоке инициализации</li><li>{{c3::в конструкторе}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>в конструкторе</li><li>{{c4::в нестатическом методе}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::при объявлении}}</li><li>{{c21::в нестатическом блоке инициализации}}</li><li>{{c21::в конструкторе}}</li><li>{{c21::в нестатическом методе}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "Y_=|Vmnre", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0092_4. Основное предназначение интерфейса", 
                "определение поведения (контракта, спецификации) для некоторой сущности"
            ], 
            "flags": 0, 
            "guid": "FrtQd<Nzzy", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0092_5. Создатель интерфейса определяет...", 
                "поведение (контракт) для сущности: сигнатуры и возвращаемые значения методов, при необходимости public static final поля. Начиная с Java 8 можно объявлять статические и default методы.&nbsp;"
            ], 
            "flags": 0, 
            "guid": "v98svlE6sU", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0092_6. Какой модификатор доступа неявно имеют все методы интерфейса", 
                "Все методы неявно объявляются как&nbsp;<code class=\"myCodeClass\">public static final</code>."
            ], 
            "flags": 0, 
            "guid": "j54XWF<Aii", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0092_3. Начиная с&nbsp;<font color=\"#00aa00\">Java 8</font>&nbsp;в интерфейсах разрешается {{c1::размещать реализацию методов по умолчанию&nbsp;<code class=\"myCodeClass\">default</code>&nbsp;и статических&nbsp;<code class=\"myCodeClass\">static</code>&nbsp;методов.}}", 
                ""
            ], 
            "flags": 0, 
            "guid": "D<f_Bi!RyR", 
            "note_model_uuid": "ef2c1764-a69a-11ea-993c-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0092_2. Может ли интерфейс содержать поля?", 
                "Да. Они автоматически являются публичными&nbsp;<code class=\"myCodeClass\">public</code>, статическими&nbsp;<code class=\"myCodeClass\">static</code>&nbsp;и неизменяемыми&nbsp;<code class=\"myCodeClass\">final</code>."
            ], 
            "flags": 0, 
            "guid": "Qea3`ya:6<", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<code class=\"myCodeClass\" style=\"background-color: rgb(235, 233, 249); \">assert</code>&nbsp;(Утверждение) — это [[oc1::специальная конструкция, позволяющая проверять предположения о значениях произвольных данных в произвольном месте программы.]] Утверждение может автоматически сигнализировать об [[oc2::&nbsp;обнаружении некорректных данных, что обычно приводит к аварийному завершению программы с указанием места обнаружения некорректных данных.]]", 
                "<code class=\"myCodeClass\" style=\"background-color: rgb(235, 233, 249); \">0136. assert</code>&nbsp;(Утверждение) — это", 
                "", 
                "", 
                "0,1,0 | n,n,n,n", 
                "<code class=\"myCodeClass\" style=\"background-color: rgb(235, 233, 249); \">assert</code>&nbsp;(Утверждение) — это {{c1::специальная конструкция, позволяющая проверять предположения о значениях произвольных данных в произвольном месте программы.}} Утверждение может автоматически сигнализировать об ...", 
                "<code class=\"myCodeClass\" style=\"background-color: rgb(235, 233, 249); \">assert</code>&nbsp;(Утверждение) — это ... Утверждение может автоматически сигнализировать об {{c2::&nbsp;обнаружении некорректных данных, что обычно приводит к аварийному завершению программы с указанием места обнаружения некорректных данных.}}", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "<code class=\"myCodeClass\" style=\"background-color: rgb(235, 233, 249); \">assert</code>&nbsp;(Утверждение) — это {{c21::специальная конструкция, позволяющая проверять предположения о значениях произвольных данных в произвольном месте программы.}} Утверждение может автоматически сигнализировать об {{c21::&nbsp;обнаружении некорректных данных, что обычно приводит к аварийному завершению программы с указанием места обнаружения некорректных данных.}}"
            ], 
            "flags": 0, 
            "guid": "O{#}wjfzM&", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": [
                "marked"
            ]
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0138. Обычно утверждения оставляют включенными {{c1::&nbsp;во время разработки и тестирования программ, но отключают в релиз-версиях программ.}}", 
                ""
            ], 
            "flags": 0, 
            "guid": "c_e)/UZoC+", 
            "note_model_uuid": "ef2c1764-a69a-11ea-993c-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0140. Что не стоит делать в конструкциях assert?", 
                "Т.к. утверждения могут быть удалены на этапе компиляции либо во время исполнения программы, они не должны менять поведение программы. Таким образом, внутри&nbsp;<span style=\"background-color: rgb(235, 233, 249)\"><code class=\"myCodeClass\">assert</code></span>&nbsp;нельзя вызывать методы, изменяющие состояние программы, либо внешнего окружения программы."
            ], 
            "flags": 0, 
            "guid": "q.)I0MEG`Q", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0138. В Java проверка утверждений реализована с помощью&nbsp;{{c1::оператора&nbsp;<span style=\"background-color: rgb(235, 233, 249)\"><code class=\"myCodeClass\">assert</code></span>, который имеет форму:<div><br /></div><span style=\"background-color: rgb(235, 233, 249); \"><code class=\"myCodeClass\">assert [Выражение типа boolean];</code></span>&nbsp;или&nbsp;<code class=\"myCodeClass\" style=\"background-color: rgb(235, 233, 249); \">assert [Выражение типа boolean] : [Выражение любого типа, кроме void];</code>}}", 
                ""
            ], 
            "flags": 0, 
            "guid": "L;8]Ja|D;0", 
            "note_model_uuid": "ef2c1764-a69a-11ea-993c-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0138_1. Во время выполнения программы в том случае, если поверка утверждений включена,&nbsp;{{c1::&nbsp;вычисляется значение булевского выражения в операторе <code class=\"myCodeClass\">assert</code>}},&nbsp;&nbsp;и если&nbsp;{{c2::&nbsp;его результат&nbsp;<span style=\"background-color: rgb(235, 233, 249)\"><code class=\"myCodeClass\">false</code></span>, то генерируется исключение&nbsp;<span style=\"background-color: rgb(235, 233, 249); \"><code class=\"myCodeClass\">java.lang.AssertionError</code></span>.}}", 
                ""
            ], 
            "flags": 0, 
            "guid": "O8[P%J9L[6", 
            "note_model_uuid": "ef2c1764-a69a-11ea-993c-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0139. В случае использования второй формы оператора&nbsp;<span style=\"background-color: rgb(235, 233, 249)\"><code class=\"myCodeClass\">assert&nbsp;{{c1::выражение после двоеточия задаёт сообщение о произошедшей ошибке (передано конструктору&nbsp;<span style=\"background-color: rgb(235, 233, 249); \"></span></code><code class=\"myCodeClass\">AssertionError</code></span>).}}", 
                ""
            ], 
            "flags": 0, 
            "guid": "l5L?G_):P?", 
            "note_model_uuid": "ef2c1764-a69a-11ea-993c-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0101_1. Синтаксис блоков инициализации", 
                "Блоки инициализации представляют собой код, заключенный в фигурные скобки и размещаемый внутри класса вне объявления методов или конструкторов."
            ], 
            "flags": 0, 
            "guid": "mHKN|IRM%m", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0125_1. Особенность создания&nbsp;статического внутреннего класса.", 
                "Для создания объекта статического внутреннего класса объект внешнего класса не требуется."
            ], 
            "flags": 0, 
            "guid": "c3sm1maYMC", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0125_2. Из объекта статического вложенного класса&nbsp;нельзя&nbsp;{{c1::обращаться к нестатическим членам обрамляющего класса напрямую, а только через ссылку на экземпляр внешнего класса.}}", 
                ""
            ], 
            "flags": 0, 
            "guid": "q;|MpoQN/`", 
            "note_model_uuid": "ef2c1764-a69a-11ea-993c-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0026. Что такое JVM?", 
                "<b>JVM, Java Virtual Machine</b>&nbsp;(Виртуальная машина Java) — основная часть среды времени исполнения Java (<b>JRE</b>). Исполняет байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java. JVM может также использоваться для выполнения программ, написанных на других языках программирования."
            ], 
            "flags": 0, 
            "guid": "K5|bNI-,XA", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0027. Что такое JRE?", 
                "<b>JRE, Java Runtime Environment</b>&nbsp;(Среда времени выполнения Java) - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из JVM и стандартного набора библиотек классов Java."
            ], 
            "flags": 0, 
            "guid": "ir*~C,Ka26", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0028. Что такое JDK?", 
                "<b>JDK, Java Development Kit</b>&nbsp;-&nbsp;<b>JRE</b>&nbsp;и набор инструментов разработчика приложений на языке Java, включающий в себя компилятор Java, стандартные библиотеки классов Java, примеры, документацию, различные утилиты."
            ], 
            "flags": 0, 
            "guid": "N=AaNM|MlX", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ul><li>&nbsp; &nbsp; Модификатор final&nbsp;может применяться к переменным, параметрам методов, полям и методам класса или самим классам.</li><li>&nbsp; &nbsp; Класс не может иметь наследников;</li><li>&nbsp; &nbsp; Метод не может быть переопределен в классах наследниках;</li><li>&nbsp; &nbsp; Поле не может изменить свое значение после инициализации;</li><li>&nbsp; &nbsp; Параметры методов не могут изменять своё значение внутри метода;</li><li>&nbsp; &nbsp; Локальные переменные не могут быть изменены после присвоения им значения..</li></ul>", 
                "0031. О чем говорит ключевое слово&nbsp;<code class=\"myCodeClass\">final</code>?", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::&nbsp; &nbsp; Модификатор final&nbsp;может применяться к переменным, параметрам методов, полям и методам класса или самим классам.}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ul>", 
                "<ul><li>&nbsp; &nbsp; Модификатор final&nbsp;может применяться к переменным, параметрам методов, полям и методам класса или самим классам.</li><li>{{c2::&nbsp; &nbsp; Класс не может иметь наследников;}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ul>", 
                "<ul><li>...</li><li>&nbsp; &nbsp; Класс не может иметь наследников;</li><li>{{c3::&nbsp; &nbsp; Метод не может быть переопределен в классах наследниках;}}</li><li>...</li><li>...</li><li>...</li></ul>", 
                "<ul><li>...</li><li>...</li><li>&nbsp; &nbsp; Метод не может быть переопределен в классах наследниках;</li><li>{{c4::&nbsp; &nbsp; Поле не может изменить свое значение после инициализации;}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>...</li><li>...</li><li>...</li><li>&nbsp; &nbsp; Поле не может изменить свое значение после инициализации;</li><li>{{c5::&nbsp; &nbsp; Параметры методов не могут изменять своё значение внутри метода;}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>...</li><li>...</li><li>...</li><li>&nbsp; &nbsp; Параметры методов не могут изменять своё значение внутри метода;</li><li>{{c6::&nbsp; &nbsp; Локальные переменные не могут быть изменены после присвоения им значения..}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::&nbsp; &nbsp; Модификатор final&nbsp;может применяться к переменным, параметрам методов, полям и методам класса или самим классам.}}</li><li>{{c21::&nbsp; &nbsp; Класс не может иметь наследников;}}</li><li>{{c21::&nbsp; &nbsp; Метод не может быть переопределен в классах наследниках;}}</li><li>{{c21::&nbsp; &nbsp; Поле не может изменить свое значение после инициализации;}}</li><li>{{c21::&nbsp; &nbsp; Параметры методов не могут изменять своё значение внутри метода;}}</li><li>{{c21::&nbsp; &nbsp; Локальные переменные не могут быть изменены после присвоения им значения..}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "f}I?v),8T/", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0037. Абстрактный класс", 
                "Класс помеченный модификатором <code class=\"myCodeClass\">abstract</code> называется абстрактным классом. Такие классы могут выступать только предками для других классов. Создавать экземпляры самого абстрактного класса не разрешается. При этом наследниками абстрактного класса могут быть как другие абстрактные классы, так и классы, допускающие создание объектов."
            ], 
            "flags": 0, 
            "guid": "Qyqw~xMid@", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ul><li>80% времени уходит на поддержку кода.</li><li>Редко когда софт поддерживается одним разработчиком</li><li>Конвенции улучшают читаемость кода, что позвляет другим лучше понимать код</li><li>Если код продается как продукт он должен быть хорошо организован и чист</li></ul>", 
                "0039. Зачем нам Code Conventions", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::80% времени уходит на поддержку кода.}}</li><li>...</li><li>...</li><li>...</li></ul>", 
                "<ul><li>80% времени уходит на поддержку кода.</li><li>{{c2::Редко когда софт поддерживается одним разработчиком}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>...</li><li>Редко когда софт поддерживается одним разработчиком</li><li>{{c3::Конвенции улучшают читаемость кода, что позвляет другим лучше понимать код}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>...</li><li>Конвенции улучшают читаемость кода, что позвляет другим лучше понимать код</li><li>{{c4::Если код продается как продукт он должен быть хорошо организован и чист}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::80% времени уходит на поддержку кода.}}</li><li>{{c21::Редко когда софт поддерживается одним разработчиком}}</li><li>{{c21::Конвенции улучшают читаемость кода, что позвляет другим лучше понимать код}}</li><li>{{c21::Если код продается как продукт он должен быть хорошо организован и чист}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "oue}Z#&a`B", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": [
                "JCC"
            ]
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>автоматическое управление памятью;</li><li>расширенные возможности обработки исключительных ситуаций;</li><li>богатый набор средств фильтрации ввода-вывода;</li><li>набор стандартных коллекций: массив, список, стек и т. п.;</li><li>наличие простых средств создания сетевых приложений;</li><li>наличие классов, позволяющих выполнять HTTP-запросы и обрабатывать ответы;</li><li>встроенные в язык средства создания многопоточных приложений;</li><li>унифицированный доступ к базам данных;</li><li>поддержка обобщений (начиная с версии 1.5);</li></ol></div>", 
                "0025_1. Назовите основные возможности Java&nbsp;", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::автоматическое управление памятью;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>автоматическое управление памятью;</li><li>{{c2::расширенные возможности обработки исключительных ситуаций;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>расширенные возможности обработки исключительных ситуаций;</li><li>{{c3::богатый набор средств фильтрации ввода-вывода;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>богатый набор средств фильтрации ввода-вывода;</li><li>{{c4::набор стандартных коллекций: массив, список, стек и т. п.;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>набор стандартных коллекций: массив, список, стек и т. п.;</li><li>{{c5::наличие простых средств создания сетевых приложений;}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>наличие простых средств создания сетевых приложений;</li><li>{{c6::наличие классов, позволяющих выполнять HTTP-запросы и обрабатывать ответы;}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>наличие классов, позволяющих выполнять HTTP-запросы и обрабатывать ответы;</li><li>{{c7::встроенные в язык средства создания многопоточных приложений;}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>встроенные в язык средства создания многопоточных приложений;</li><li>{{c8::унифицированный доступ к базам данных;}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>унифицированный доступ к базам данных;</li><li>{{c9::поддержка обобщений (начиная с версии 1.5);}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::автоматическое управление памятью;}}</li><li>{{c21::расширенные возможности обработки исключительных ситуаций;}}</li><li>{{c21::богатый набор средств фильтрации ввода-вывода;}}</li><li>{{c21::набор стандартных коллекций: массив, список, стек и т. п.;}}</li><li>{{c21::наличие простых средств создания сетевых приложений;}}</li><li>{{c21::наличие классов, позволяющих выполнять HTTP-запросы и обрабатывать ответы;}}</li><li>{{c21::встроенные в язык средства создания многопоточных приложений;}}</li><li>{{c21::унифицированный доступ к базам данных;}}</li><li>{{c21::поддержка обобщений (начиная с версии 1.5);}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "O@(UIao6u)", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": [
                "epam"
            ]
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0025_4. Порядок вычисления для бинарных операторов", 
                "Слева направо"
            ], 
            "flags": 0, 
            "guid": "J;dj&|ckMz", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": [
                "epam"
            ]
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0025_4. Порядок вычисления для операторов присваивания", 
                "Справа налево"
            ], 
            "flags": 0, 
            "guid": "E_6]SZQO7T", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": [
                "epam"
            ]
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ol><li>++expr (префиксный инкремент)</li><li>--expr&nbsp;(префиксный декремент)</li><li>exp++&nbsp;(постфиксный инкремент)</li><li>exp--&nbsp;(постфиксный декремент)</li><li>+expr (унарный плюс)</li><li>-expr (унарный минус)</li><li>~ (инверсия битов)</li><li>! (НЕ)</li></ol>", 
                "0025_5. Unary operators", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::++expr (префиксный инкремент)}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>++expr (префиксный инкремент)</li><li>{{c2::--expr&nbsp;(префиксный декремент)}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>--expr&nbsp;(префиксный декремент)</li><li>{{c3::exp++&nbsp;(постфиксный инкремент)}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>exp++&nbsp;(постфиксный инкремент)</li><li>{{c4::exp--&nbsp;(постфиксный декремент)}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>exp--&nbsp;(постфиксный декремент)</li><li>{{c5::+expr (унарный плюс)}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>+expr (унарный плюс)</li><li>{{c6::-expr (унарный минус)}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>-expr (унарный минус)</li><li>{{c7::~ (инверсия битов)}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>~ (инверсия битов)</li><li>{{c8::! (НЕ)}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::++expr (префиксный инкремент)}}</li><li>{{c21::--expr&nbsp;(префиксный декремент)}}</li><li>{{c21::exp++&nbsp;(постфиксный инкремент)}}</li><li>{{c21::exp--&nbsp;(постфиксный декремент)}}</li><li>{{c21::+expr (унарный плюс)}}</li><li>{{c21::-expr (унарный минус)}}</li><li>{{c21::~ (инверсия битов)}}</li><li>{{c21::! (НЕ)}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "GlNk{k*j&0", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": [
                "epam"
            ]
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ol><li>access array element [ ],&nbsp;access object member . (dot) , parentheses ()&nbsp;</li><li>postfix&nbsp;expr++ expr--</li><li>unary</li><li>cast (), new object creation</li><li>multiplicative (mult, divide, modulo)</li><li>additive (plus, minus, string concatenation)</li><li>shift &nbsp;&lt;&lt; &gt;&gt; &gt;&gt;&gt;</li><li>relational&nbsp;</li><li>equality &nbsp;== !=</li><li>bitwise AND &amp;</li><li>bitwise exclusive OR (XOR) ^</li><li>bitwise inclusive OR |</li><li>logical AND &amp;&amp;</li><li>logical OR ||</li><li>ternary ? :</li><li>assignment</li></ol>", 
                "0025_3. Приоритет операций в порядке от высшего к низшему", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::access array element [ ],&nbsp;access object member . (dot) , parentheses ()&nbsp;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>access array element [ ],&nbsp;access object member . (dot) , parentheses ()&nbsp;</li><li>{{c2::postfix&nbsp;expr++ expr--}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>postfix&nbsp;expr++ expr--</li><li>{{c3::unary}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>unary</li><li>{{c4::cast (), new object creation}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>cast (), new object creation</li><li>{{c5::multiplicative (mult, divide, modulo)}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>multiplicative (mult, divide, modulo)</li><li>{{c6::additive (plus, minus, string concatenation)}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>additive (plus, minus, string concatenation)</li><li>{{c7::shift &nbsp;&lt;&lt; &gt;&gt; &gt;&gt;&gt;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>shift &nbsp;&lt;&lt; &gt;&gt; &gt;&gt;&gt;</li><li>{{c8::relational&nbsp;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>relational&nbsp;</li><li>{{c9::equality &nbsp;== !=}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>equality &nbsp;== !=</li><li>{{c10::bitwise AND &amp;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>bitwise AND &amp;</li><li>{{c11::bitwise exclusive OR (XOR) ^}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>bitwise exclusive OR (XOR) ^</li><li>{{c12::bitwise inclusive OR |}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>bitwise inclusive OR |</li><li>{{c13::logical AND &amp;&amp;}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>logical AND &amp;&amp;</li><li>{{c14::logical OR ||}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>logical OR ||</li><li>{{c15::ternary ? :}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>ternary ? :</li><li>{{c16::assignment}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::access array element [ ],&nbsp;access object member . (dot) , parentheses ()&nbsp;}}</li><li>{{c21::postfix&nbsp;expr++ expr--}}</li><li>{{c21::unary}}</li><li>{{c21::cast (), new object creation}}</li><li>{{c21::multiplicative (mult, divide, modulo)}}</li><li>{{c21::additive (plus, minus, string concatenation)}}</li><li>{{c21::shift &nbsp;&lt;&lt; &gt;&gt; &gt;&gt;&gt;}}</li><li>{{c21::relational&nbsp;}}</li><li>{{c21::equality &nbsp;== !=}}</li><li>{{c21::bitwise AND &amp;}}</li><li>{{c21::bitwise exclusive OR (XOR) ^}}</li><li>{{c21::bitwise inclusive OR |}}</li><li>{{c21::logical AND &amp;&amp;}}</li><li>{{c21::logical OR ||}}</li><li>{{c21::ternary ? :}}</li><li>{{c21::assignment}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "A&iMW)`bS`", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": [
                "epam"
            ]
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0025_6.&nbsp;relational operators", 
                "&lt; &gt; &lt;= &gt;= instanceof"
            ], 
            "flags": 0, 
            "guid": "l3Hf<s}VXU", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": [
                "epam"
            ]
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ol><li>=&nbsp;</li><li>+=&nbsp;</li><li>-=&nbsp;</li><li>*=&nbsp;</li><li>/=&nbsp;</li><li>%=&nbsp;</li><li>&amp;=&nbsp;</li><li>^=&nbsp;</li><li>|=&nbsp;</li><li>&lt;&lt;=&nbsp;</li><li>&gt;&gt;=&nbsp;</li><li>&gt;&gt;&gt;=</li></ol>", 
                "0026_7.&nbsp;assignment operators", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::=&nbsp;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>=&nbsp;</li><li>{{c2::+=&nbsp;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>+=&nbsp;</li><li>{{c3::-=&nbsp;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>-=&nbsp;</li><li>{{c4::*=&nbsp;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>*=&nbsp;</li><li>{{c5::/=&nbsp;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>/=&nbsp;</li><li>{{c6::%=&nbsp;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>%=&nbsp;</li><li>{{c7::&amp;=&nbsp;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>&amp;=&nbsp;</li><li>{{c8::^=&nbsp;}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>^=&nbsp;</li><li>{{c9::|=&nbsp;}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>|=&nbsp;</li><li>{{c10::&lt;&lt;=&nbsp;}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>&lt;&lt;=&nbsp;</li><li>{{c11::&gt;&gt;=&nbsp;}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>&gt;&gt;=&nbsp;</li><li>{{c12::&gt;&gt;&gt;=}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::=&nbsp;}}</li><li>{{c21::+=&nbsp;}}</li><li>{{c21::-=&nbsp;}}</li><li>{{c21::*=&nbsp;}}</li><li>{{c21::/=&nbsp;}}</li><li>{{c21::%=&nbsp;}}</li><li>{{c21::&amp;=&nbsp;}}</li><li>{{c21::^=&nbsp;}}</li><li>{{c21::|=&nbsp;}}</li><li>{{c21::&lt;&lt;=&nbsp;}}</li><li>{{c21::&gt;&gt;=&nbsp;}}</li><li>{{c21::&gt;&gt;&gt;=}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "p,N6PZaUw+", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": [
                "epam", 
                "marked"
            ]
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>short to char,&nbsp;byte&nbsp;</li><li>char to short,&nbsp;byte</li><li>int to char, short or byte</li><li>long to int, char, short, byte</li><li>float to long, int, char, short, byte</li><li>double to float, long, int, char, short, byte</li></ol></div>", 
                "0027_2.&nbsp;Narrowing Primitive Conversion", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::short to char,&nbsp;byte&nbsp;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>short to char,&nbsp;byte&nbsp;</li><li>{{c2::char to short,&nbsp;byte}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>char to short,&nbsp;byte</li><li>{{c3::int to char, short or byte}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>int to char, short or byte</li><li>{{c4::long to int, char, short, byte}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>long to int, char, short, byte</li><li>{{c5::float to long, int, char, short, byte}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>float to long, int, char, short, byte</li><li>{{c6::double to float, long, int, char, short, byte}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::short to char,&nbsp;byte&nbsp;}}</li><li>{{c21::char to short,&nbsp;byte}}</li><li>{{c21::int to char, short or byte}}</li><li>{{c21::long to int, char, short, byte}}</li><li>{{c21::float to long, int, char, short, byte}}</li><li>{{c21::double to float, long, int, char, short, byte}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "D>T`A~F784", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": [
                "epam"
            ]
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0027_1. Ряд расширяющих преобразований", 
                "byte &gt;&gt; short &gt;&gt; int &nbsp;&gt;&gt; long &gt;&gt; float &gt;&gt; double"
            ], 
            "flags": 0, 
            "guid": "I6m3j>N&-j", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": [
                "epam", 
                "marked"
            ]
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ul><li>в случае построения иерархии однотипных, очень похожих друг на друга классов.</li><li>Когда нужно передать наследникам поля или методы c модификаторами protected или package-private</li><li>Когда нужно объявить не-static и не-final поля</li></ul>", 
                "0094.&nbsp;В каких случаях следует использовать абстрактный класс?", 
                "<div>Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах. При этом все подклассы схожи между собой в части реализации, унаследованной от абстрактного класса и отличаются лишь в части собственной реализации абстрактных методов родителя. Поэтому абстрактные классы применяются в случае построения иерархии однотипных, очень похожих друг на друга классов. В этом случае наследование от абстрактного класса, реализующего поведение объекта по умолчанию может быть полезно, так как позволяет избежать написания повторяющегося кода. Во всех остальных случаях лучше использовать интерфейсы.</div>", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::в случае построения иерархии однотипных, очень похожих друг на друга классов.}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>в случае построения иерархии однотипных, очень похожих друг на друга классов.</li><li>{{c2::Когда нужно передать наследникам поля или методы c модификаторами protected или package-private}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>Когда нужно передать наследникам поля или методы c модификаторами protected или package-private</li><li>{{c3::Когда нужно объявить не-static и не-final поля}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::в случае построения иерархии однотипных, очень похожих друг на друга классов.}}</li><li>{{c21::Когда нужно передать наследникам поля или методы c модификаторами protected или package-private}}</li><li>{{c21::Когда нужно объявить не-static и не-final поля}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "w!=OG!6q2^", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ul><li>Когда ожидается что несвязанные между собой классы будут реализовывать некое поведение. Например, интерфейсы Comparable, Clonable.</li><li>Когда нужно определить поведение некоторого типа, но неважно определять кто будет его реализововать.</li><li>Нужно иметь возможность реализовать несколько различных типов поведения (спецификаций) в одном классе</li></ul>", 
                "0095. В каких случаях стоит использовать интерфейсы?", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::Когда ожидается что несвязанные между собой классы будут реализовывать некое поведение. Например, интерфейсы Comparable, Clonable.}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>Когда ожидается что несвязанные между собой классы будут реализовывать некое поведение. Например, интерфейсы Comparable, Clonable.</li><li>{{c2::Когда нужно определить поведение некоторого типа, но неважно определять кто будет его реализововать.}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>Когда нужно определить поведение некоторого типа, но неважно определять кто будет его реализововать.</li><li>{{c3::Нужно иметь возможность реализовать несколько различных типов поведения (спецификаций) в одном классе}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::Когда ожидается что несвязанные между собой классы будут реализовывать некое поведение. Например, интерфейсы Comparable, Clonable.}}</li><li>{{c21::Когда нужно определить поведение некоторого типа, но неважно определять кто будет его реализововать.}}</li><li>{{c21::Нужно иметь возможность реализовать несколько различных типов поведения (спецификаций) в одном классе}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "Ct~7}rqTKE", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0106. Может ли статический метод быть переопределен?", 
                "<div>нет. Выбор вызываемого статического метода происходит при раннем связывании (на этапе компиляции, а не выполнения) и выполняться всегда будет родительский метод, хотя синтаксически переопределение статического метода это вполне корректная языковая конструкция.</div><div>В целом, к статическим полям и методам рекомендуется обращаться через имя класса, а не объект.</div>"
            ], 
            "flags": 0, 
            "guid": "lBpyySAw=k", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0108.&nbsp;Возможно ли при переопределении метода изменить модификатор доступа", 
                "При переопределении метода сужать модификатор доступа не разрешается, т.к. это приведёт к нарушению принципа подстановки Барбары Лисков. Расширение уровня доступа возможно."
            ], 
            "flags": 0, 
            "guid": "Q>[/8gr,BA", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0109.&nbsp;Возможно ли при переопределении метода изменить&nbsp;возвращаемый тип?", 
                "Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника)."
            ], 
            "flags": 0, 
            "guid": "I(m]Z]Z!GR", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0110.&nbsp;Возможно ли при переопределении метода изменить&nbsp;тип аргумента или их количество, имена аргументов или их порядок?", 
                "При изменении типа, количества, порядка следования аргументов вместо переопределения будет происходить overloading (перегрузка) метода. Изменять имена аргументов при переопределении можно."
            ], 
            "flags": 0, 
            "guid": "Fq)h(kL#:~", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0111.&nbsp;Возможно ли при переопределении метода&nbsp;убирать, добавлять, изменять порядок следования элементов секции throws?", 
                "Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет."
            ], 
            "flags": 0, 
            "guid": "Q1JF0uJ[@X", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div>Статический внутренний класс</div><div>Простой внутренний класс (member inner class)</div><div>Локальный класс</div><div>Анонимный класс</div>", 
                "<div>0119. Виды внутренних классов</div>", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<div>{{c1::Статический внутренний класс}}</div><div>...</div><div>...</div><div>...</div>", 
                "<div>Статический внутренний класс</div><div>{{c2::Простой внутренний класс (member inner class)}}</div><div>...</div><div>...</div>", 
                "<div>...</div><div>Простой внутренний класс (member inner class)</div><div>{{c3::Локальный класс}}</div><div>...</div>", 
                "<div>...</div><div>...</div><div>Локальный класс</div><div>{{c4::Анонимный класс}}</div>", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "<div>{{c21::Статический внутренний класс}}</div><div>{{c21::Простой внутренний класс (member inner class)}}</div><div>{{c21::Локальный класс}}</div><div>{{c21::Анонимный класс}}</div>"
            ], 
            "flags": 0, 
            "guid": "IJ_D5M>zss", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ol><li>Определение внутреннего класса</li><li>Зачем использовать внутренние классы</li><li>Имеют ли доступ к полям и методам внешнего класса? Наоборот?</li><li>Перечислить категории виды внутренних классов и когда используются</li></ol>", 
                "0120. План ответа на вопрос - Расскажите про внутренние классы. В каких случаях они применяются?", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::Определение внутреннего класса}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>Определение внутреннего класса</li><li>{{c2::Зачем использовать внутренние классы}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>Зачем использовать внутренние классы</li><li>{{c3::Имеют ли доступ к полям и методам внешнего класса? Наоборот?}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>Имеют ли доступ к полям и методам внешнего класса? Наоборот?</li><li>{{c4::Перечислить категории виды внутренних классов и когда используются}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::Определение внутреннего класса}}</li><li>{{c21::Зачем использовать внутренние классы}}</li><li>{{c21::Имеют ли доступ к полям и методам внешнего класса? Наоборот?}}</li><li>{{c21::Перечислить категории виды внутренних классов и когда используются}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "A4Fy]iYuT9", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0121.&nbsp;Определение внутреннего класса", 
                "<div>Класс называется внутренним (Nested class), если он определен внутри другого класса.</div>"
            ], 
            "flags": 0, 
            "guid": "xy-K~&EIH7", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0122.&nbsp;Зачем использовать вложенные классы", 
                "В том случае, когда класс нужен только для обслуживания какого-то одного класса. Иначе - стоит сделать его внешним."
            ], 
            "flags": 0, 
            "guid": "h>7AgyH53~", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0123.&nbsp;Имеют ли внутренние классы доступ к полям и методам внешнего класса? Наоборот?", 
                "Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам внешнего класса, но не наоборот.&nbsp;"
            ], 
            "flags": 0, 
            "guid": "C19e){ln({", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ul><li>вложенный класс должен быть виден за пределами одного метода</li><li>он слишком длинный для того, чтобы его можно было удобно разместить в границах одного метода</li><li>если каждому экземпляру внутреннего класса необходима ссылка на экземпляр включающего его внешнего класса</li></ul>", 
                "<div>0124.&nbsp;Когда использовать&nbsp;нестатический внутренний класс?</div>", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::вложенный класс должен быть виден за пределами одного метода}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>вложенный класс должен быть виден за пределами одного метода</li><li>{{c2::он слишком длинный для того, чтобы его можно было удобно разместить в границах одного метода}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>он слишком длинный для того, чтобы его можно было удобно разместить в границах одного метода</li><li>{{c3::если каждому экземпляру внутреннего класса необходима ссылка на экземпляр включающего его внешнего класса}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::вложенный класс должен быть виден за пределами одного метода}}</li><li>{{c21::он слишком длинный для того, чтобы его можно было удобно разместить в границах одного метода}}</li><li>{{c21::если каждому экземпляру внутреннего класса необходима ссылка на экземпляр включающего его внешнего класса}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "LyMWO;~<A/", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0125.&nbsp;Когда использовать&nbsp;статический внутренний класс", 
                "если ссылка на обрамляющий класс не требуется - лучше сделать внутренний класс статическим"
            ], 
            "flags": 0, 
            "guid": "lin2xHfQ~K", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0126.&nbsp;Когда использовать&nbsp;локальный внутренний класс", 
                "Если класс необходим только внутри какого-то метода и требуется создавать экземпляры этого класса только в этом методе"
            ], 
            "flags": 0, 
            "guid": "vv+lz_;Tf&", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0127.&nbsp;Когда использовать анонимный&nbsp;внутренний класс", 
                "если применение класса сводится к использованию лишь в одном месте и уже существует тип, характеризующий этот класс"
            ], 
            "flags": 0, 
            "guid": "yyDeAkx#TF", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>Видны только в пределах блока, в котором объявлены;</li><li>Не могут быть объявлены как private/public/protected&nbsp;или static;</li><li>Не могут иметь внутри себя статических объявлений (полей, методов, классов);</li><li>Имеют доступ к полям и методам обрамляющего класса;</li><li>Могут обращаться к локальным переменным и параметрам метода, но изменять их не могут.</li></ol></div>", 
                "0131. Особенности локальных классов", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::Видны только в пределах блока, в котором объявлены;}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>Видны только в пределах блока, в котором объявлены;</li><li>{{c2::Не могут быть объявлены как private/public/protected&nbsp;или static;}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>Не могут быть объявлены как private/public/protected&nbsp;или static;</li><li>{{c3::Не могут иметь внутри себя статических объявлений (полей, методов, классов);}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>Не могут иметь внутри себя статических объявлений (полей, методов, классов);</li><li>{{c4::Имеют доступ к полям и методам обрамляющего класса;}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>Имеют доступ к полям и методам обрамляющего класса;</li><li>{{c5::Могут обращаться к локальным переменным и параметрам метода, но изменять их не могут.}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::Видны только в пределах блока, в котором объявлены;}}</li><li>{{c21::Не могут быть объявлены как private/public/protected&nbsp;или static;}}</li><li>{{c21::Не могут иметь внутри себя статических объявлений (полей, методов, классов);}}</li><li>{{c21::Имеют доступ к полям и методам обрамляющего класса;}}</li><li>{{c21::Могут обращаться к локальным переменным и параметрам метода, но изменять их не могут.}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "FY4]}xkC^%", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ul><li>&nbsp; &nbsp; Должны реализовывать существующий интерфейс или наследовать какой-то базовый класс</li><li>&nbsp; &nbsp; Не могут объявлять каких-либо новых методов, лишь реализуют методы своего интерфейса или базового класса</li><li>&nbsp; &nbsp; Не могут иметь конструктор.&nbsp;</li></ul>", 
                "0133. Ограничения анонимных классов", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::&nbsp; &nbsp; Должны реализовывать существующий интерфейс или наследовать какой-то базовый класс}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>&nbsp; &nbsp; Должны реализовывать существующий интерфейс или наследовать какой-то базовый класс</li><li>{{c2::&nbsp; &nbsp; Не могут объявлять каких-либо новых методов, лишь реализуют методы своего интерфейса или базового класса}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>&nbsp; &nbsp; Не могут объявлять каких-либо новых методов, лишь реализуют методы своего интерфейса или базового класса</li><li>{{c3::&nbsp; &nbsp; Не могут иметь конструктор.&nbsp;}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::&nbsp; &nbsp; Должны реализовывать существующий интерфейс или наследовать какой-то базовый класс}}</li><li>{{c21::&nbsp; &nbsp; Не могут объявлять каких-либо новых методов, лишь реализуют методы своего интерфейса или базового класса}}</li><li>{{c21::&nbsp; &nbsp; Не могут иметь конструктор.&nbsp;}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "c>X+#Jjt!8", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>для создания объекта-функции (function object), например реализация интерфейса&nbsp;Comparator</li><li>для придания уникальной функциональности отдельно взятому экземпляру какого-либо класса</li><li>для обработки событий</li><li>запуска&nbsp;потоков и т.д.</li></ol></div>", 
                "<div>0133. Где применяются анонимные классы?</div>", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::для создания объекта-функции (function object), например реализация интерфейса&nbsp;Comparator}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>для создания объекта-функции (function object), например реализация интерфейса&nbsp;Comparator</li><li>{{c2::для придания уникальной функциональности отдельно взятому экземпляру какого-либо класса}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>для придания уникальной функциональности отдельно взятому экземпляру какого-либо класса</li><li>{{c3::для обработки событий}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>для обработки событий</li><li>{{c4::запуска&nbsp;потоков и т.д.}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::для создания объекта-функции (function object), например реализация интерфейса&nbsp;Comparator}}</li><li>{{c21::для придания уникальной функциональности отдельно взятому экземпляру какого-либо класса}}</li><li>{{c21::для обработки событий}}</li><li>{{c21::запуска&nbsp;потоков и т.д.}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "s%J@/r48f7", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "Утверждения существенно упрощают [[oc1::локализацию ошибок в коде.]]<div>Даже проверка результатов выполнения очевидного кода может оказаться полезной при&nbsp;[[oc2::&nbsp;последующем рефакторинге, после которого код может стать не настолько очевидным и в него может закрасться ошибка.]]</div>", 
                "0137.&nbsp;Утверждения существенно", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "Утверждения существенно упрощают {{c1::локализацию ошибок в коде.}}<div>Даже проверка результатов выполнения очевидного кода может оказаться полезной при&nbsp;...</div>", 
                "Утверждения существенно упрощают локализацию ошибок в коде.<div>Даже проверка результатов выполнения очевидного кода может оказаться полезной при&nbsp;{{c2::&nbsp;последующем рефакторинге, после которого код может стать не настолько очевидным и в него может закрасться ошибка.}}</div>", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "Утверждения существенно упрощают {{c21::локализацию ошибок в коде.}}<div>Даже проверка результатов выполнения очевидного кода может оказаться полезной при&nbsp;{{c21::&nbsp;последующем рефакторинге, после которого код может стать не настолько очевидным и в него может закрасться ошибка.}}</div>"
            ], 
            "flags": 0, 
            "guid": "f#GZp#_&Dc", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div>Stack (стек) это [[oc1:: область памяти, которая содержит локальные переменные: примитивы и ссылки на объекты, которые находятся в куче, и организована по принципу LIFO&nbsp;]]&nbsp;</div><div>Всякий раз, когда вызывается метод, [[oc2:: на вершине стека создается новый фрейм, который содержит локальные переменные метода.]] &nbsp;Как только метод заканчивает работу, [[oc3:: фрейм удаляется и доступ предоставляется следующему методу (фрейму).]] Размер стековой памяти [[oc4::намного меньше объема памяти в куче, но работает стек быстрее. ]] Во время исполнения программы создается [[oc5::&nbsp;отдельный стек на каждый отдельный поток.]]</div>", 
                "0142.&nbsp;Что такое Stack память в Java?", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<div>Stack (стек) это {{c1:: область памяти, которая содержит локальные переменные: примитивы и ссылки на объекты, которые находятся в куче, и организована по принципу LIFO&nbsp;}}&nbsp;</div><div>Всякий раз, когда вызывается метод, ... &nbsp;Как только метод заканчивает работу, ... Размер стековой памяти ... Во время исполнения программы создается ...</div>", 
                "<div>Stack (стек) это  область памяти, которая содержит локальные переменные: примитивы и ссылки на объекты, которые находятся в куче, и организована по принципу LIFO&nbsp;&nbsp;</div><div>Всякий раз, когда вызывается метод, {{c2:: на вершине стека создается новый фрейм, который содержит локальные переменные метода.}} &nbsp;Как только метод заканчивает работу, ... Размер стековой памяти ... Во время исполнения программы создается ...</div>", 
                "<div>Stack (стек) это ...&nbsp;</div><div>Всякий раз, когда вызывается метод,  на вершине стека создается новый фрейм, который содержит локальные переменные метода. &nbsp;Как только метод заканчивает работу, {{c3:: фрейм удаляется и доступ предоставляется следующему методу (фрейму).}} Размер стековой памяти ... Во время исполнения программы создается ...</div>", 
                "<div>Stack (стек) это ...&nbsp;</div><div>Всякий раз, когда вызывается метод, ... &nbsp;Как только метод заканчивает работу,  фрейм удаляется и доступ предоставляется следующему методу (фрейму). Размер стековой памяти {{c4::намного меньше объема памяти в куче, но работает стек быстрее. }} Во время исполнения программы создается ...</div>", 
                "<div>Stack (стек) это ...&nbsp;</div><div>Всякий раз, когда вызывается метод, ... &nbsp;Как только метод заканчивает работу, ... Размер стековой памяти намного меньше объема памяти в куче, но работает стек быстрее.  Во время исполнения программы создается {{c5::&nbsp;отдельный стек на каждый отдельный поток.}}</div>", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "<div>Stack (стек) это {{c21:: область памяти, которая содержит локальные переменные: примитивы и ссылки на объекты, которые находятся в куче, и организована по принципу LIFO&nbsp;}}&nbsp;</div><div>Всякий раз, когда вызывается метод, {{c21:: на вершине стека создается новый фрейм, который содержит локальные переменные метода.}} &nbsp;Как только метод заканчивает работу, {{c21:: фрейм удаляется и доступ предоставляется следующему методу (фрейму).}} Размер стековой памяти {{c21::намного меньше объема памяти в куче, но работает стек быстрее. }} Во время исполнения программы создается {{c21::&nbsp;отдельный стек на каждый отдельный поток.}}</div>"
            ], 
            "flags": 0, 
            "guid": "M`E>aPBn3g", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "[[oc1::часть стека, которая хранит данные - примитивы и ссылки на объекты и возвращаемое значение метода]]<div>Новый фрейм [[oc2::создается и кладется в стек каждый раз при вызове метода.&nbsp;]]</div><div>После завершения [[oc3:: работы метода фрейм удаляется (pop) из стека.]]</div>", 
                "0144. Что такое фрейм", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "{{c1::часть стека, которая хранит данные - примитивы и ссылки на объекты и возвращаемое значение метода}}<div>Новый фрейм ...</div><div>После завершения ...</div>", 
                "часть стека, которая хранит данные - примитивы и ссылки на объекты и возвращаемое значение метода<div>Новый фрейм {{c2::создается и кладется в стек каждый раз при вызове метода.&nbsp;}}</div><div>После завершения ...</div>", 
                "...<div>Новый фрейм создается и кладется в стек каждый раз при вызове метода.&nbsp;</div><div>После завершения {{c3:: работы метода фрейм удаляется (pop) из стека.}}</div>", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "{{c21::часть стека, которая хранит данные - примитивы и ссылки на объекты и возвращаемое значение метода}}<div>Новый фрейм {{c21::создается и кладется в стек каждый раз при вызове метода.&nbsp;}}</div><div>После завершения {{c21:: работы метода фрейм удаляется (pop) из стека.}}</div>"
            ], 
            "flags": 0, 
            "guid": "D6ID<}Ba^^", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>&nbsp; &nbsp; Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится лишь ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.</li><li>&nbsp; &nbsp; Куча используется всеми частями приложения и объекты в куче доступны из любой точки программы, в то время как стек используется только одним потоком исполнения программы и другие потоки не могут получить к нему доступ.</li><li>&nbsp; &nbsp; Управление памятью в стеке осуществляется по схеме LIFO.</li><li>&nbsp; &nbsp; Если память стека полностью занята, то Java Runtime бросает исключение java.lang.StackOverflowError. Если заполнена память кучи, то бросается исключение java.lang.OutOfMemoryError: Java Heap Space.</li><li>&nbsp; &nbsp; Размер памяти стека намного меньше памяти в куче.</li><li>&nbsp; &nbsp; Из-за простоты распределения памяти, стековая память работает намного быстрее кучи.</li></ol></div>", 
                "0143. Различия между Heap и Stack памятью", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::&nbsp; &nbsp; Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится лишь ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>&nbsp; &nbsp; Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится лишь ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.</li><li>{{c2::&nbsp; &nbsp; Куча используется всеми частями приложения и объекты в куче доступны из любой точки программы, в то время как стек используется только одним потоком исполнения программы и другие потоки не могут получить к нему доступ.}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>&nbsp; &nbsp; Куча используется всеми частями приложения и объекты в куче доступны из любой точки программы, в то время как стек используется только одним потоком исполнения программы и другие потоки не могут получить к нему доступ.</li><li>{{c3::&nbsp; &nbsp; Управление памятью в стеке осуществляется по схеме LIFO.}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>&nbsp; &nbsp; Управление памятью в стеке осуществляется по схеме LIFO.</li><li>{{c4::&nbsp; &nbsp; Если память стека полностью занята, то Java Runtime бросает исключение java.lang.StackOverflowError. Если заполнена память кучи, то бросается исключение java.lang.OutOfMemoryError: Java Heap Space.}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>&nbsp; &nbsp; Если память стека полностью занята, то Java Runtime бросает исключение java.lang.StackOverflowError. Если заполнена память кучи, то бросается исключение java.lang.OutOfMemoryError: Java Heap Space.</li><li>{{c5::&nbsp; &nbsp; Размер памяти стека намного меньше памяти в куче.}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>&nbsp; &nbsp; Размер памяти стека намного меньше памяти в куче.</li><li>{{c6::&nbsp; &nbsp; Из-за простоты распределения памяти, стековая память работает намного быстрее кучи.}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::&nbsp; &nbsp; Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится лишь ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.}}</li><li>{{c21::&nbsp; &nbsp; Куча используется всеми частями приложения и объекты в куче доступны из любой точки программы, в то время как стек используется только одним потоком исполнения программы и другие потоки не могут получить к нему доступ.}}</li><li>{{c21::&nbsp; &nbsp; Управление памятью в стеке осуществляется по схеме LIFO.}}</li><li>{{c21::&nbsp; &nbsp; Если память стека полностью занята, то Java Runtime бросает исключение java.lang.StackOverflowError. Если заполнена память кучи, то бросается исключение java.lang.OutOfMemoryError: Java Heap Space.}}</li><li>{{c21::&nbsp; &nbsp; Размер памяти стека намного меньше памяти в куче.}}</li><li>{{c21::&nbsp; &nbsp; Из-за простоты распределения памяти, стековая память работает намного быстрее кучи.}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "zbRxv!&W;S", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0143_1. Как определить размер памяти для кучи?", 
                "Для определения начального и максимального размера памяти в куче используются -Xms и -Xmx опции JVM."
            ], 
            "flags": 0, 
            "guid": "vi*]@{]By.", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0143_2. Как задать размер стека?", 
                "Для стека определить размер памяти можно с помощью опции -Xss."
            ], 
            "flags": 0, 
            "guid": "05t>%QVX!", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ul><li>Для чего нужен</li><li>подходы к обнаружению мусора. рассказать о них</li><li>Методы очистки памяти от мусора</li><li>Как работает сборщик мусора</li></ul>", 
                "0147. Рассказать про сборщик мусора - план ответа", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::Для чего нужен}}</li><li>...</li><li>...</li><li>...</li></ul>", 
                "<ul><li>Для чего нужен</li><li>{{c2::подходы к обнаружению мусора. рассказать о них}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>...</li><li>подходы к обнаружению мусора. рассказать о них</li><li>{{c3::Методы очистки памяти от мусора}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>...</li><li>Методы очистки памяти от мусора</li><li>{{c4::Как работает сборщик мусора}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::Для чего нужен}}</li><li>{{c21::подходы к обнаружению мусора. рассказать о них}}</li><li>{{c21::Методы очистки памяти от мусора}}</li><li>{{c21::Как работает сборщик мусора}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "yMPDb071-k", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "Находить мусор - неиспользуемые объекты.<div>Освобождать память от мусора.</div>", 
                "0148. Что должен делать сборщик мусора", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<div>{{c1::Находить мусор - неиспользуемые объекты.}}</div><div>...</div>", 
                "<div>Находить мусор - неиспользуемые объекты.</div><div>{{c2::Освобождать память от мусора.}}</div>", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "<div>{{c21::Находить мусор - неиспользуемые объекты.}}</div><div>{{c21::Освобождать память от мусора.}}</div>"
            ], 
            "flags": 0, 
            "guid": "OOe+qhjK2,", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "Объект считается неиспользуемым, если&nbsp;[[oc1::ни одна из сущностей в коде, выполняемом в данный момент, не содержит ссылок на него]]&nbsp;либо [[oc2::цепочка ссылок, которая могла бы связать объект с некоторой сущностью приложения, обрывается]]", 
                "0149. Какой объект считается неиспользуемым", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "Объект считается неиспользуемым, если&nbsp;{{c1::ни одна из сущностей в коде, выполняемом в данный момент, не содержит ссылок на него}}&nbsp;либо ...", 
                "Объект считается неиспользуемым, если&nbsp;ни одна из сущностей в коде, выполняемом в данный момент, не содержит ссылок на него&nbsp;либо {{c2::цепочка ссылок, которая могла бы связать объект с некоторой сущностью приложения, обрывается}}", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "Объект считается неиспользуемым, если&nbsp;{{c21::ни одна из сущностей в коде, выполняемом в данный момент, не содержит ссылок на него}}&nbsp;либо {{c21::цепочка ссылок, которая могла бы связать объект с некоторой сущностью приложения, обрывается}}"
            ], 
            "flags": 0, 
            "guid": "F<rR_&Dg@3", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div>Reference counting;</div><div>Tracing</div>", 
                "0150. Два подхода к обнаружению мусора", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<div>{{c1::Reference counting;}}</div><div>...</div>", 
                "<div>Reference counting;</div><div>{{c2::Tracing}}</div>", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "<div>{{c21::Reference counting;}}</div><div>{{c21::Tracing}}</div>"
            ], 
            "flags": 0, 
            "guid": "o-e]`m)>9r", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0151. расскажите про Reference counting", 
                "Суть этого подхода состоит в том, что каждый объект имеет счетчик. Счетчик хранит информацию о том, сколько ссылок указывает на объект. Когда ссылка уничтожается, счетчик уменьшается. Если значение счетчика равно нулю, - объект можно считать мусором."
            ], 
            "flags": 0, 
            "guid": "yDcTLlNVuM", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0152. Основной минус&nbsp;Reference counting", 
                "Главным минусом такого подхода является сложность обеспечения точности счетчика. Также при таком подходе сложно выявлять циклические зависимости, что приводит к утечкам памяти."
            ], 
            "flags": 0, 
            "guid": "O0(BP}=dk=", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0153. Что такое циклическая зависимость объектов", 
                "когда два объекта указывают друг на друга, но ни один живой объект на них не ссылается"
            ], 
            "flags": 0, 
            "guid": "oco$i~&%r/", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0154. Расскажите про метод очистки&nbsp;Tracing&nbsp;", 
                "Главная идея подхода Tracing (трассировка) состоит в утверждении, что живыми могут считаться только те объекты, до которых мы можем добраться из корневых точек (GC Root) и те объекты, которые доступны с живого объекта. Всё остальное - мусор."
            ], 
            "flags": 0, 
            "guid": "bE{G40P=;[", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ul><li>&nbsp; &nbsp; Локальные переменные и параметры методов;</li><li>&nbsp; &nbsp; Потоки;</li><li>&nbsp; &nbsp; Статические переменные;</li><li>&nbsp; &nbsp; Ссылки из JNI.</li></ul></div>", 
                "0155.&nbsp;4 типа корневых точки (GC Roots)", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::&nbsp; &nbsp; Локальные переменные и параметры методов;}}</li><li>...</li><li>...</li><li>...</li></ul>", 
                "<ul><li>&nbsp; &nbsp; Локальные переменные и параметры методов;</li><li>{{c2::&nbsp; &nbsp; Потоки;}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>...</li><li>&nbsp; &nbsp; Потоки;</li><li>{{c3::&nbsp; &nbsp; Статические переменные;}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>...</li><li>&nbsp; &nbsp; Статические переменные;</li><li>{{c4::&nbsp; &nbsp; Ссылки из JNI.}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::&nbsp; &nbsp; Локальные переменные и параметры методов;}}</li><li>{{c21::&nbsp; &nbsp; Потоки;}}</li><li>{{c21::&nbsp; &nbsp; Статические переменные;}}</li><li>{{c21::&nbsp; &nbsp; Ссылки из JNI.}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "Gw9pj_sFh~", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ul><li>&nbsp; &nbsp; Локальные переменные внутри main() метода и параметры main() метода;</li><li>&nbsp; &nbsp; Поток который выполняет main();</li><li>&nbsp; &nbsp; Статические переменные класса, внутри которого находится main() метод.</li></ul></div>", 
                "0156.&nbsp;Самое простое java приложение будет иметь корневые точки:", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::&nbsp; &nbsp; Локальные переменные внутри main() метода и параметры main() метода;}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>&nbsp; &nbsp; Локальные переменные внутри main() метода и параметры main() метода;</li><li>{{c2::&nbsp; &nbsp; Поток который выполняет main();}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>&nbsp; &nbsp; Поток который выполняет main();</li><li>{{c3::&nbsp; &nbsp; Статические переменные класса, внутри которого находится main() метод.}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::&nbsp; &nbsp; Локальные переменные внутри main() метода и параметры main() метода;}}</li><li>{{c21::&nbsp; &nbsp; Поток который выполняет main();}}</li><li>{{c21::&nbsp; &nbsp; Статические переменные класса, внутри которого находится main() метод.}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "CELBx1bswP", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "Таким образом, если мы представим [[oc1::все объекты и ссылки между ними как дерево, то нам нужно будет пройти с корневых узлов (точек) по всем рёбрам.]] При этом узлы[[oc2::, до которых мы сможем добраться - не мусор, все остальные - мусор.]] При таком подходе [[oc3::циклические зависимости легко выявляются. HotSpot VM использует именно такой подход.]]", 
                "0157. Трассировка", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "Таким образом, если мы представим {{c1::все объекты и ссылки между ними как дерево, то нам нужно будет пройти с корневых узлов (точек) по всем рёбрам.}} При этом узлы... При таком подходе ...", 
                "Таким образом, если мы представим все объекты и ссылки между ними как дерево, то нам нужно будет пройти с корневых узлов (точек) по всем рёбрам. При этом узлы{{c2::, до которых мы сможем добраться - не мусор, все остальные - мусор.}} При таком подходе ...", 
                "Таким образом, если мы представим ... При этом узлы, до которых мы сможем добраться - не мусор, все остальные - мусор. При таком подходе {{c3::циклические зависимости легко выявляются. HotSpot VM использует именно такой подход.}}", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "Таким образом, если мы представим {{c21::все объекты и ссылки между ними как дерево, то нам нужно будет пройти с корневых узлов (точек) по всем рёбрам.}} При этом узлы{{c21::, до которых мы сможем добраться - не мусор, все остальные - мусор.}} При таком подходе {{c21::циклические зависимости легко выявляются. HotSpot VM использует именно такой подход.}}"
            ], 
            "flags": 0, 
            "guid": "sp<V=5=;^d", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ul><li>&nbsp; &nbsp; Copying collectors</li><li>&nbsp; &nbsp; Mark-and-sweep</li></ul></div><div><br /></div>", 
                "0158.&nbsp;Для очистки памяти от мусора существуют два основных метода", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::&nbsp; &nbsp; Copying collectors}}</li><li>...</li></ul>", 
                "<ul><li>&nbsp; &nbsp; Copying collectors</li><li>{{c2::&nbsp; &nbsp; Mark-and-sweep}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::&nbsp; &nbsp; Copying collectors}}</li><li>{{c21::&nbsp; &nbsp; Mark-and-sweep}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "CpJEQ#IAb^", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0159. При подходе&nbsp;copying collectors память делится на&nbsp;{{c1::«from-space» и «to-space»}}", 
                ""
            ], 
            "flags": 0, 
            "guid": "T&O:]Em9*", 
            "note_model_uuid": "ef2c1764-a69a-11ea-993c-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ul><li>&nbsp; &nbsp; Объекты создаются в «from-space»;</li><li>&nbsp; &nbsp; Когда «from-space» заполняется, приложение приостанавливается;</li><li>&nbsp; &nbsp; Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «to-space»;</li><li>&nbsp; &nbsp; Когда все объекты скопированы «from-space» полностью очищается;</li><li>&nbsp; &nbsp; «to-space» и «from-space» меняются местами.</li></ul></div>", 
                "0160. Принцип работы&nbsp;copying collectors", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::&nbsp; &nbsp; Объекты создаются в «from-space»;}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ul>", 
                "<ul><li>&nbsp; &nbsp; Объекты создаются в «from-space»;</li><li>{{c2::&nbsp; &nbsp; Когда «from-space» заполняется, приложение приостанавливается;}}</li><li>...</li><li>...</li><li>...</li></ul>", 
                "<ul><li>...</li><li>&nbsp; &nbsp; Когда «from-space» заполняется, приложение приостанавливается;</li><li>{{c3::&nbsp; &nbsp; Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «to-space»;}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>...</li><li>...</li><li>&nbsp; &nbsp; Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «to-space»;</li><li>{{c4::&nbsp; &nbsp; Когда все объекты скопированы «from-space» полностью очищается;}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>...</li><li>...</li><li>&nbsp; &nbsp; Когда все объекты скопированы «from-space» полностью очищается;</li><li>{{c5::&nbsp; &nbsp; «to-space» и «from-space» меняются местами.}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::&nbsp; &nbsp; Объекты создаются в «from-space»;}}</li><li>{{c21::&nbsp; &nbsp; Когда «from-space» заполняется, приложение приостанавливается;}}</li><li>{{c21::&nbsp; &nbsp; Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «to-space»;}}</li><li>{{c21::&nbsp; &nbsp; Когда все объекты скопированы «from-space» полностью очищается;}}</li><li>{{c21::&nbsp; &nbsp; «to-space» и «from-space» меняются местами.}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "m[S_vO%>)1", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0161.&nbsp;Главный плюс&nbsp;Copying collectors", 
                "объекты плотно забивают память."
            ], 
            "flags": 0, 
            "guid": "e.LSnJ$.sl", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ul><li>&nbsp; &nbsp; Приложение должно быть остановлено на время, необходимое для полного прохождения цикла сборки мусора;</li><li>&nbsp; &nbsp; В худшем случае (когда все объекты живые) «form-space» и «to-space» будут обязаны быть одинакового размера.</li></ul>", 
                "0162.&nbsp;Минусы подхода&nbsp;Copying collectors", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::&nbsp; &nbsp; Приложение должно быть остановлено на время, необходимое для полного прохождения цикла сборки мусора;}}</li><li>...</li></ul>", 
                "<ul><li>&nbsp; &nbsp; Приложение должно быть остановлено на время, необходимое для полного прохождения цикла сборки мусора;</li><li>{{c2::&nbsp; &nbsp; В худшем случае (когда все объекты живые) «form-space» и «to-space» будут обязаны быть одинакового размера.}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::&nbsp; &nbsp; Приложение должно быть остановлено на время, необходимое для полного прохождения цикла сборки мусора;}}</li><li>{{c21::&nbsp; &nbsp; В худшем случае (когда все объекты живые) «form-space» и «to-space» будут обязаны быть одинакового размера.}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "r-d2`:Z(Dl", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ul><li>&nbsp; &nbsp; &nbsp;Объекты создаются в памяти;</li><li>&nbsp; &nbsp; В момент, когда нужно запустить сборщик мусора приложение приостанавливается;</li><li>&nbsp; &nbsp; Сборщик проходится по дереву объектов, помечая живые объекты;</li><li>&nbsp; &nbsp; Сборщик проходится по всей памяти, находя все не отмеченные куски памяти и сохраняя их в «free list»;</li><li>&nbsp; &nbsp; Когда новые объекты начинают создаваться они создаются в памяти доступной во «free list».</li></ul></div>", 
                "0163.&nbsp;Алгоритм работы mark-and-sweep можно описать так", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::&nbsp; &nbsp; &nbsp;Объекты создаются в памяти;}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ul>", 
                "<ul><li>&nbsp; &nbsp; &nbsp;Объекты создаются в памяти;</li><li>{{c2::&nbsp; &nbsp; В момент, когда нужно запустить сборщик мусора приложение приостанавливается;}}</li><li>...</li><li>...</li><li>...</li></ul>", 
                "<ul><li>...</li><li>&nbsp; &nbsp; В момент, когда нужно запустить сборщик мусора приложение приостанавливается;</li><li>{{c3::&nbsp; &nbsp; Сборщик проходится по дереву объектов, помечая живые объекты;}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>...</li><li>...</li><li>&nbsp; &nbsp; Сборщик проходится по дереву объектов, помечая живые объекты;</li><li>{{c4::&nbsp; &nbsp; Сборщик проходится по всей памяти, находя все не отмеченные куски памяти и сохраняя их в «free list»;}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>...</li><li>...</li><li>&nbsp; &nbsp; Сборщик проходится по всей памяти, находя все не отмеченные куски памяти и сохраняя их в «free list»;</li><li>{{c5::&nbsp; &nbsp; Когда новые объекты начинают создаваться они создаются в памяти доступной во «free list».}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::&nbsp; &nbsp; &nbsp;Объекты создаются в памяти;}}</li><li>{{c21::&nbsp; &nbsp; В момент, когда нужно запустить сборщик мусора приложение приостанавливается;}}</li><li>{{c21::&nbsp; &nbsp; Сборщик проходится по дереву объектов, помечая живые объекты;}}</li><li>{{c21::&nbsp; &nbsp; Сборщик проходится по всей памяти, находя все не отмеченные куски памяти и сохраняя их в «free list»;}}</li><li>{{c21::&nbsp; &nbsp; Когда новые объекты начинают создаваться они создаются в памяти доступной во «free list».}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "z=]*%UQjF[", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0164.&nbsp;Механизм сборки мусора - это", 
                "процесс освобождения места в куче, для возможности добавления новых объектов."
            ], 
            "flags": 0, 
            "guid": "BM0ODsV)Al", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0165.&nbsp;Что такое «пул строк»?", 
                "область в памяти, где JVM хранит строки"
            ], 
            "flags": 0, 
            "guid": "JyrdLnFKBg", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0129_1. Обращение с внутренними классами [[oc1::происходит на уровне компилятора, а не виртуальной машины.]] Для их обозначения [[oc2::используется знак $. Т.е имя внутреннего класса после компиляции выглядит как имя_внешнего_класса$имя_внутреннего_класса]] Таким образом, [[oc3::для JVM внутренние классы неотличимы от внешних.]]", 
                "0129_1. Обращение с внутренними классами...&nbsp;", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "0129_1. Обращение с внутренними классами {{c1::происходит на уровне компилятора, а не виртуальной машины.}} Для их обозначения ... Таким образом, ...", 
                "0129_1. Обращение с внутренними классами происходит на уровне компилятора, а не виртуальной машины. Для их обозначения {{c2::используется знак $. Т.е имя внутреннего класса после компиляции выглядит как имя_внешнего_класса$имя_внутреннего_класса}} Таким образом, ...", 
                "0129_1. Обращение с внутренними классами ... Для их обозначения используется знак $. Т.е имя внутреннего класса после компиляции выглядит как имя_внешнего_класса$имя_внутреннего_класса Таким образом, {{c3::для JVM внутренние классы неотличимы от внешних.}}", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "0129_1. Обращение с внутренними классами {{c21::происходит на уровне компилятора, а не виртуальной машины.}} Для их обозначения {{c21::используется знак $. Т.е имя внутреннего класса после компиляции выглядит как имя_внешнего_класса$имя_внутреннего_класса}} Таким образом, {{c21::для JVM внутренние классы неотличимы от внешних.}}"
            ], 
            "flags": 0, 
            "guid": "g:)rnJv#+^", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0129_2. Каким образом внутренние классы получают дополнительные права доступа, если после компиляции они преобразуются в обычные и JVM о них ничего не известно?", 
                "Компилятор генерирует специальный метод, которому передает ссылку на внешний класс."
            ], 
            "flags": 0, 
            "guid": "If|q9T2[_~", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0131_1. Если нужно использовать локальную переменую в локальном классе (например, в качестве счетчика), как обойти ограничение на неизменяемость?", 
                "Объявить переменную массивом единичной длинны и положить элементом нужное значение.&nbsp;"
            ], 
            "flags": 0, 
            "guid": "z0(&<2408/", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0128_1. Приведите пример использования внутреннего класса", 
                "Например, нужно сделать метод, в котором удобно возвращать пару значений, скажем, при поиске наибольшего и наименьшего числа в массиве, и чтобы не проходить массив дважды, можно сразу же проверять каждое значение на min-max, тогда чтобы &nbsp;вернуть оба значения, можно положить их в класс-обертку c названием, например, Pair, а чтобы не забивать пространство имен, безопасно сделать этот класс внутренним."
            ], 
            "flags": 0, 
            "guid": "F+3iUUOx,[", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0128_2. Внутренние классы, определенные в интерфейсах, {{c1::автоматически считаются static и public}}", 
                ""
            ], 
            "flags": 0, 
            "guid": "PgIHi2)9;|", 
            "note_model_uuid": "ef2c1764-a69a-11ea-993c-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0091_1. план ответа о массивах", 
                "<div><ol><li>определение массива</li><li>Длинна массива</li><li>Индексы элементов в массиве</li><li>Каким типом данных является массив</li><li>Размещение в памяти</li><li>Операции с массивами</li></ol></div>"
            ], 
            "flags": 0, 
            "guid": "e@)z6aVH^Q", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0091_2. Массив - это&nbsp;", 
                "&nbsp;структура данных, представляющая собой конечную последовательность упорядоченных элементов одного типа (допуская полиморфизм), доступ к каждому элементу в которой осуществляется по его индексу."
            ], 
            "flags": 0, 
            "guid": "s4*`w|@z?Z", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0091_3.&nbsp;Размер или длина массива", 
                "это общее количество элементов в массиве. Размер массива задаётся при создании массива и не может быть изменён в дальнейшем, т. е. нельзя убрать элементы из массива или добавить их туда, но можно в существующие элементы присвоить новые значения."
            ], 
            "flags": 0, 
            "guid": "Dm>?<u*9~F", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0091_4. Индексы элементов в массиве", 
                "Индекс начального элемента массива&nbsp;&nbsp;— 0, следующего за ним — 1 и т. д. Индекс последнего элемента в массиве — на единицу меньше, чем размер массива."
            ], 
            "flags": 0, 
            "guid": "Rb$Le{sJp^", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0091_5. Каким типом данных является массив", 
                "В Java массивы являются объектами (ссылочными типами). Это значит, что имя, которое даётся каждому массиву, лишь указывает на адрес какого-то фрагмента данных в памяти. Кроме адреса в этой переменной ничего не хранится."
            ], 
            "flags": 0, 
            "guid": "Qm79k1Z1=;", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0091_6.&nbsp;Индекс массива, фактически, указывает на то, {{c1::насколько надо отступить от начального элемента массива в памяти, чтоб добраться до нужного элемента.}}", 
                ""
            ], 
            "flags": 0, 
            "guid": "JHv=<W#LUq", 
            "note_model_uuid": "ef2c1764-a69a-11ea-993c-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ul><li>Размещение элементов массива в едином блоке памяти является ключевой особенностью массивов.&nbsp;</li><li>Такое размещение позволяет максимально эффективно получать доступ к любому наперёд заданному элементу массива.&nbsp;</li><li>Зная адрес массива — номер ячейки памяти, начиная с которой в ней последовательно располагаются элементы массива, иными словами, зная адрес элемента с индексом 0, и учитывая, что все элементы массива в силу их однотипности занимают в памяти одинаковое количество ячеек, можно легко получить адрес элемента с любым заданным индексом i.&nbsp;</li></ul></div>", 
                "0091_7.&nbsp;Размещение элементов массива в памяти", 
                "", 
                "<img src=\"paste-46226733006851.png\" />", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::Размещение элементов массива в едином блоке памяти является ключевой особенностью массивов.&nbsp;}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>Размещение элементов массива в едином блоке памяти является ключевой особенностью массивов.&nbsp;</li><li>{{c2::Такое размещение позволяет максимально эффективно получать доступ к любому наперёд заданному элементу массива.&nbsp;}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>Такое размещение позволяет максимально эффективно получать доступ к любому наперёд заданному элементу массива.&nbsp;</li><li>{{c3::Зная адрес массива — номер ячейки памяти, начиная с которой в ней последовательно располагаются элементы массива, иными словами, зная адрес элемента с индексом 0, и учитывая, что все элементы массива в силу их однотипности занимают в памяти одинаковое количество ячеек, можно легко получить адрес элемента с любым заданным индексом i.&nbsp;}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::Размещение элементов массива в едином блоке памяти является ключевой особенностью массивов.&nbsp;}}</li><li>{{c21::Такое размещение позволяет максимально эффективно получать доступ к любому наперёд заданному элементу массива.&nbsp;}}</li><li>{{c21::Зная адрес массива — номер ячейки памяти, начиная с которой в ней последовательно располагаются элементы массива, иными словами, зная адрес элемента с индексом 0, и учитывая, что все элементы массива в силу их однотипности занимают в памяти одинаковое количество ячеек, можно легко получить адрес элемента с любым заданным индексом i.&nbsp;}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "dIo`3@v#r?", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>Статические поля и блоки инициализации&nbsp;класса Parent;</li><li>Статические поля и блоки инициализации&nbsp;класса Сhild;</li><li>Нестатические поля и блоки инициализации класса Parent;</li><li>Конструктор класса Parent;</li><li>Нестатические поля и блоки инициализации класса Сhild;</li><li>Конструктор класса Сhild.</li></ol></div>", 
                "0092_1.&nbsp;Порядок инициализации объекта для случая наследования класов:&nbsp;public class Child extends Parent&nbsp;", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::Статические поля и блоки инициализации&nbsp;класса Parent;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>Статические поля и блоки инициализации&nbsp;класса Parent;</li><li>{{c2::Статические поля и блоки инициализации&nbsp;класса Сhild;}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>Статические поля и блоки инициализации&nbsp;класса Сhild;</li><li>{{c3::Нестатические поля и блоки инициализации класса Parent;}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>Нестатические поля и блоки инициализации класса Parent;</li><li>{{c4::Конструктор класса Parent;}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>Конструктор класса Parent;</li><li>{{c5::Нестатические поля и блоки инициализации класса Сhild;}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>Нестатические поля и блоки инициализации класса Сhild;</li><li>{{c6::Конструктор класса Сhild.}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::Статические поля и блоки инициализации&nbsp;класса Parent;}}</li><li>{{c21::Статические поля и блоки инициализации&nbsp;класса Сhild;}}</li><li>{{c21::Нестатические поля и блоки инициализации класса Parent;}}</li><li>{{c21::Конструктор класса Parent;}}</li><li>{{c21::Нестатические поля и блоки инициализации класса Сhild;}}</li><li>{{c21::Конструктор класса Сhild.}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "b(?OCkiI!5", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0141_1.&nbsp;Что такое&nbsp;Heap в Java?", 
                "Java Heap (куча) &nbsp;- динамически распредляемая область памяти, создаваемая при старте JVM, в которой хранятся объекты."
            ], 
            "flags": 0, 
            "guid": "E__ipD+QCX", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0141_3. Как соотносятся Heap память и сборщик мусора?", 
                "Heap память является областью работы сборщика мусора"
            ], 
            "flags": 0, 
            "guid": "<z$dDAK=8", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0141_4.&nbsp;Любой объект, созданный в куче, имеет {{c1::&nbsp;глобальный }} доступ и на него могут ссылаться из {{c2::любой части приложения.}}", 
                ""
            ], 
            "flags": 0, 
            "guid": "jXjsk6$j:t", 
            "note_model_uuid": "ef2c1764-a69a-11ea-993c-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0141_5.&nbsp;Количество выделенной памяти для объекта в куче зависит от {{c1::&nbsp;набора и размера полей}}", 
                ""
            ], 
            "flags": 0, 
            "guid": "hLnkUJX&Ox", 
            "note_model_uuid": "ef2c1764-a69a-11ea-993c-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0167. Что такое класс String в Java", 
                "класс в Java для представления текстовых неизменяемых строк.&nbsp;находится в пакете java.lang.<br />"
            ], 
            "flags": 0, 
            "guid": "oPBL3kbQkT", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>&nbsp; &nbsp; Класс не может иметь наследников;</li><li>&nbsp; &nbsp; Метод не может быть переопределен в классах наследниках;</li><li>&nbsp; &nbsp; Поле не может изменить свое значение после инициализации;</li><li>&nbsp; &nbsp; Локальные переменные не могут быть изменены после присвоения им значения;</li><li>&nbsp; &nbsp; Параметры методов не могут изменять своё значение внутри метода.</li></ol></div>", 
                "0168. Модификатор final", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::&nbsp; &nbsp; Класс не может иметь наследников;}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>&nbsp; &nbsp; Класс не может иметь наследников;</li><li>{{c2::&nbsp; &nbsp; Метод не может быть переопределен в классах наследниках;}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>&nbsp; &nbsp; Метод не может быть переопределен в классах наследниках;</li><li>{{c3::&nbsp; &nbsp; Поле не может изменить свое значение после инициализации;}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>&nbsp; &nbsp; Поле не может изменить свое значение после инициализации;</li><li>{{c4::&nbsp; &nbsp; Локальные переменные не могут быть изменены после присвоения им значения;}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>&nbsp; &nbsp; Локальные переменные не могут быть изменены после присвоения им значения;</li><li>{{c5::&nbsp; &nbsp; Параметры методов не могут изменять своё значение внутри метода.}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::&nbsp; &nbsp; Класс не может иметь наследников;}}</li><li>{{c21::&nbsp; &nbsp; Метод не может быть переопределен в классах наследниках;}}</li><li>{{c21::&nbsp; &nbsp; Поле не может изменить свое значение после инициализации;}}</li><li>{{c21::&nbsp; &nbsp; Локальные переменные не могут быть изменены после присвоения им значения;}}</li><li>{{c21::&nbsp; &nbsp; Параметры методов не могут изменять своё значение внутри метода.}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "lt,8,bSN(f", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0169.&nbsp;Оператор finally", 
                "гарантирует, что определенный в нём участок кода будет выполнен независимо от того, какие исключения были возбуждены и перехвачены в блоке try-catch.&nbsp;обрабатывается всегда, кроме случаем убивающих Jvm или подвешивающих программу"
            ], 
            "flags": 0, 
            "guid": "i95x@yZ#<O", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0170.&nbsp;Метод finalize()", 
                "должен вызываться&nbsp;перед тем как сборщик мусора будет проводить удаление объекта, но вызов его не гарантируется. начиная с Java 9 deprecated"
            ], 
            "flags": 0, 
            "guid": "B^{3IV.DaV", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0171. Что такое приведение типов&nbsp;(casting)?", 
                "способ преобразования значения переменной одного типа в значение другого типа."
            ], 
            "flags": 0, 
            "guid": "tm092mPezM", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ol><li>Тождественное (identity)</li><li>Расширение (повышение, upcasting) примитивного типа (widening primitive).</li><li>Сужение (понижение, downcasting) примитивного типа (narrowing primitive).</li><li>Расширение объектного типа (widening reference).</li><li>Сужение объектного типа (narrowing reference).</li><li>Преобразование к строке (to String).</li><li>Запрещенные преобразования (forbidden).</li></ol>", 
                "0172. Разновидности приведений типов", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::Тождественное (identity)}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>Тождественное (identity)</li><li>{{c2::Расширение (повышение, upcasting) примитивного типа (widening primitive).}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>Расширение (повышение, upcasting) примитивного типа (widening primitive).</li><li>{{c3::Сужение (понижение, downcasting) примитивного типа (narrowing primitive).}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>Сужение (понижение, downcasting) примитивного типа (narrowing primitive).</li><li>{{c4::Расширение объектного типа (widening reference).}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>Расширение объектного типа (widening reference).</li><li>{{c5::Сужение объектного типа (narrowing reference).}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>Сужение объектного типа (narrowing reference).</li><li>{{c6::Преобразование к строке (to String).}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li><li>Преобразование к строке (to String).</li><li>{{c7::Запрещенные преобразования (forbidden).}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::Тождественное (identity)}}</li><li>{{c21::Расширение (повышение, upcasting) примитивного типа (widening primitive).}}</li><li>{{c21::Сужение (понижение, downcasting) примитивного типа (narrowing primitive).}}</li><li>{{c21::Расширение объектного типа (widening reference).}}</li><li>{{c21::Сужение объектного типа (narrowing reference).}}</li><li>{{c21::Преобразование к строке (to String).}}</li><li>{{c21::Запрещенные преобразования (forbidden).}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "NnAurcR_", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0173. Что такое тождественное преобразование", 
                "Преобразование выражения любого типа к точно такому же типу всегда допустимо и происходит автоматически."
            ], 
            "flags": 0, 
            "guid": "omxq%.%:~Z", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "Означает, что [[oc1::осуществляется переход от менее емкого типа к более ёмкому.]] Например, [[oc2::от типа byte (длина 1 байт) к типу int (длина 4 байта). Такие преобразование безопасны в том смысле, что новый тип всегда гарантировано вмещает в себя все данные, которые хранились в старом типе и таким образом не происходит потери данных.]] [[oc3::Этот тип приведения всегда допустим и происходит автоматически.]]", 
                "<div>0174.&nbsp;Расширение примитивного типа?</div>", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "Означает, что {{c1::осуществляется переход от менее емкого типа к более ёмкому.}} Например, ... ...", 
                "Означает, что осуществляется переход от менее емкого типа к более ёмкому. Например, {{c2::от типа byte (длина 1 байт) к типу int (длина 4 байта). Такие преобразование безопасны в том смысле, что новый тип всегда гарантировано вмещает в себя все данные, которые хранились в старом типе и таким образом не происходит потери данных.}} ...", 
                "Означает, что ... Например, от типа byte (длина 1 байт) к типу int (длина 4 байта). Такие преобразование безопасны в том смысле, что новый тип всегда гарантировано вмещает в себя все данные, которые хранились в старом типе и таким образом не происходит потери данных. {{c3::Этот тип приведения всегда допустим и происходит автоматически.}}", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "Означает, что {{c21::осуществляется переход от менее емкого типа к более ёмкому.}} Например, {{c21::от типа byte (длина 1 байт) к типу int (длина 4 байта). Такие преобразование безопасны в том смысле, что новый тип всегда гарантировано вмещает в себя все данные, которые хранились в старом типе и таким образом не происходит потери данных.}} {{c21::Этот тип приведения всегда допустим и происходит автоматически.}}"
            ], 
            "flags": 0, 
            "guid": "nW*rNDTuCA", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "Означает, что [[oc1::переход осуществляется от более емкого типа к менее емкому.&nbsp;]]<div>[[oc2::При таком преобразовании есть риск потерять данные.&nbsp;]]</div><div>Например, [[oc3::если число типа int было больше 127 или меньше -128, то при приведении его к byte значения битов старше восьмого будут потеряны.]] В Java [[oc4::такое преобразование должно совершаться явным образом, при этом все старшие биты, не умещающиеся в новом типе, просто отбрасываются - никакого округления или других действий для получения более корректного результата не производится.]]</div>", 
                "0175.&nbsp;Сужение примитивного типа?", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "Означает, что {{c1::переход осуществляется от более емкого типа к менее емкому.&nbsp;}}<div>...</div><div>Например, ... В Java ...</div>", 
                "Означает, что переход осуществляется от более емкого типа к менее емкому.&nbsp;<div>{{c2::При таком преобразовании есть риск потерять данные.&nbsp;}}</div><div>Например, ... В Java ...</div>", 
                "Означает, что ...<div>При таком преобразовании есть риск потерять данные.&nbsp;</div><div>Например, {{c3::если число типа int было больше 127 или меньше -128, то при приведении его к byte значения битов старше восьмого будут потеряны.}} В Java ...</div>", 
                "Означает, что ...<div>...</div><div>Например, если число типа int было больше 127 или меньше -128, то при приведении его к byte значения битов старше восьмого будут потеряны. В Java {{c4::такое преобразование должно совершаться явным образом, при этом все старшие биты, не умещающиеся в новом типе, просто отбрасываются - никакого округления или других действий для получения более корректного результата не производится.}}</div>", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "Означает, что {{c21::переход осуществляется от более емкого типа к менее емкому.&nbsp;}}<div>{{c21::При таком преобразовании есть риск потерять данные.&nbsp;}}</div><div>Например, {{c21::если число типа int было больше 127 или меньше -128, то при приведении его к byte значения битов старше восьмого будут потеряны.}} В Java {{c21::такое преобразование должно совершаться явным образом, при этом все старшие биты, не умещающиеся в новом типе, просто отбрасываются - никакого округления или других действий для получения более корректного результата не производится.}}</div>"
            ], 
            "flags": 0, 
            "guid": "cY]+nc#]:=", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0176.&nbsp;Расширение объектного типа (widening reference, upcasting)?", 
                "Означает неявное восходящее приведение типов или переход от более конкретного типа к менее конкретному, т.е. переход от потомка к предку. Разрешено всегда и происходит автоматически."
            ], 
            "flags": 0, 
            "guid": "v&n8H{sd@I", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ol><li>Означает нисходящее приведение, то есть приведение от предка к потомку.</li><li>Возможно только если переменная, в которую кладется результат преобразования является подтипом приводимого типа.&nbsp;</li><li>Требует явного указания типа.</li><li>При несоответствии типов в момент выполнения выбрасывается исключение ClassCastException.&nbsp;</li></ol>", 
                "<div>0177.&nbsp;Сужение объектного типа (narrowing reference or downcasting)?</div>", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::Означает нисходящее приведение, то есть приведение от предка к потомку.}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>Означает нисходящее приведение, то есть приведение от предка к потомку.</li><li>{{c2::Возможно только если переменная, в которую кладется результат преобразования является подтипом приводимого типа.&nbsp;}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>Возможно только если переменная, в которую кладется результат преобразования является подтипом приводимого типа.&nbsp;</li><li>{{c3::Требует явного указания типа.}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>Требует явного указания типа.</li><li>{{c4::При несоответствии типов в момент выполнения выбрасывается исключение ClassCastException.&nbsp;}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::Означает нисходящее приведение, то есть приведение от предка к потомку.}}</li><li>{{c21::Возможно только если переменная, в которую кладется результат преобразования является подтипом приводимого типа.&nbsp;}}</li><li>{{c21::Требует явного указания типа.}}</li><li>{{c21::При несоответствии типов в момент выполнения выбрасывается исключение ClassCastException.&nbsp;}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "Ns@PU=FlUC", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0178.Преобразование к строке (to String)?", 
                "Любой тип может быть приведен к строке, т.е. к экземпляру класса String."
            ], 
            "flags": 0, 
            "guid": "cl@l]Q_H3q", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ul><li>К запрещенным преобразованиям относятся приведения от любого ссылочного типа к примитивному и наоборот (кроме преобразования к строке).&nbsp;</li><li>невозможно привести друг к другу классы находящиеся на разных ветвях дерева наследования.</li></ul>", 
                "0179. Запрещенные преобразования (forbidden). Приведите примеры", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::К запрещенным преобразованиям относятся приведения от любого ссылочного типа к примитивному и наоборот (кроме преобразования к строке).&nbsp;}}</li><li>...</li></ul>", 
                "<ul><li>К запрещенным преобразованиям относятся приведения от любого ссылочного типа к примитивному и наоборот (кроме преобразования к строке).&nbsp;</li><li>{{c2::невозможно привести друг к другу классы находящиеся на разных ветвях дерева наследования.}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::К запрещенным преобразованиям относятся приведения от любого ссылочного типа к примитивному и наоборот (кроме преобразования к строке).&nbsp;}}</li><li>{{c21::невозможно привести друг к другу классы находящиеся на разных ветвях дерева наследования.}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "O?r0y!q0NT", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0180.&nbsp;Что происходит с объектом при приведении типов?", 
                "С самим объектом ничего не происходит, - меняется лишь тип ссылки, через которую происходит обращение к объекту."
            ], 
            "flags": 0, 
            "guid": "KD@|g?E;;[", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0181.&nbsp;Когда в приложении может быть выброшено исключение ClassCastException?", 
                "ClassCastException (потомок RuntimeException) - исключение, которое будет выброшено при ошибке приведения типа."
            ], 
            "flags": 0, 
            "guid": "Bk<ADPJwD;", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0182.&nbsp;Что такое autoboxing («автоупаковка») в Java?", 
                "механизм неявной инициализации объектов классов-оберток (Byte, Short, Integer, Long, Float, Double, Character, Boolean) значениями соответствующих им исходных примитивных типов (byte, short, int...), без явного использования конструктора класса."
            ], 
            "flags": 0, 
            "guid": "u8lrZ)kP61", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ol><li>Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью оператора =), либо при передаче примитива в параметры метода (типа класса-обертки).</li><li>Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, так и константы времени компиляции (литералы и final-примитивы).&nbsp;</li><li>Автоупаковка переменных примитивных типов требует точного соответствия типа исходного примитива типу класса-обертки. Например, попытка упаковать переменную типа byte в Short, без предварительного явного приведения byte в short вызовет ошибку компиляции.</li><li>Автоупаковка констант примитивных типов допускает более широкие границы соответствия. В этом случае компилятор способен предварительно осуществлять неявное расширение/сужение типа примитивов.</li></ol>", 
                "0183.&nbsp;правила упаковки примитивных типов в классы-обертки?", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью оператора =), либо при передаче примитива в параметры метода (типа класса-обертки).}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью оператора =), либо при передаче примитива в параметры метода (типа класса-обертки).</li><li>{{c2::Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, так и константы времени компиляции (литералы и final-примитивы).&nbsp;}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, так и константы времени компиляции (литералы и final-примитивы).&nbsp;</li><li>{{c3::Автоупаковка переменных примитивных типов требует точного соответствия типа исходного примитива типу класса-обертки. Например, попытка упаковать переменную типа byte в Short, без предварительного явного приведения byte в short вызовет ошибку компиляции.}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>Автоупаковка переменных примитивных типов требует точного соответствия типа исходного примитива типу класса-обертки. Например, попытка упаковать переменную типа byte в Short, без предварительного явного приведения byte в short вызовет ошибку компиляции.</li><li>{{c4::Автоупаковка констант примитивных типов допускает более широкие границы соответствия. В этом случае компилятор способен предварительно осуществлять неявное расширение/сужение типа примитивов.}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью оператора =), либо при передаче примитива в параметры метода (типа класса-обертки).}}</li><li>{{c21::Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, так и константы времени компиляции (литералы и final-примитивы).&nbsp;}}</li><li>{{c21::Автоупаковка переменных примитивных типов требует точного соответствия типа исходного примитива типу класса-обертки. Например, попытка упаковать переменную типа byte в Short, без предварительного явного приведения byte в short вызовет ошибку компиляции.}}</li><li>{{c21::Автоупаковка констант примитивных типов допускает более широкие границы соответствия. В этом случае компилятор способен предварительно осуществлять неявное расширение/сужение типа примитивов.}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "j(Y#t:;.Vn", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0184.&nbsp;Дополнительной особенностью целочисленных классов-оберток созданных автоупаковкой {{c1::констант&nbsp;в диапазоне -128 ... +127 я вляется то, что они кэшируются JVM. Поэтому такие обертки с одинаковыми значениями будут являться ссылками на один объект.}}", 
                ""
            ], 
            "flags": 0, 
            "guid": "OEk0]ZZ,@6", 
            "note_model_uuid": "ef2c1764-a69a-11ea-993c-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>&nbsp; &nbsp; Это неизменяемый (immutable) и финализированный тип данных;</li><li>&nbsp; &nbsp; Все объекты класса String JVM хранит в пуле строк;</li><li>&nbsp; &nbsp; Объект класса String можно получить используя двойные кавычки;</li><li>&nbsp; &nbsp; Можно использовать оператор + для конкатенации строк;</li><li>&nbsp; &nbsp; Любой ссылочный или примитивный тип можно привести к строке.</li><li>&nbsp; &nbsp; Начиная с Java 7 строки можно использовать в конструкции switch.</li></ol></div>", 
                "0185.&nbsp;Какие есть особенности класса String?", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::&nbsp; &nbsp; Это неизменяемый (immutable) и финализированный тип данных;}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>&nbsp; &nbsp; Это неизменяемый (immutable) и финализированный тип данных;</li><li>{{c2::&nbsp; &nbsp; Все объекты класса String JVM хранит в пуле строк;}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>&nbsp; &nbsp; Все объекты класса String JVM хранит в пуле строк;</li><li>{{c3::&nbsp; &nbsp; Объект класса String можно получить используя двойные кавычки;}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>&nbsp; &nbsp; Объект класса String можно получить используя двойные кавычки;</li><li>{{c4::&nbsp; &nbsp; Можно использовать оператор + для конкатенации строк;}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>&nbsp; &nbsp; Можно использовать оператор + для конкатенации строк;</li><li>{{c5::&nbsp; &nbsp; Любой ссылочный или примитивный тип можно привести к строке.}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>&nbsp; &nbsp; Любой ссылочный или примитивный тип можно привести к строке.</li><li>{{c6::&nbsp; &nbsp; Начиная с Java 7 строки можно использовать в конструкции switch.}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::&nbsp; &nbsp; Это неизменяемый (immutable) и финализированный тип данных;}}</li><li>{{c21::&nbsp; &nbsp; Все объекты класса String JVM хранит в пуле строк;}}</li><li>{{c21::&nbsp; &nbsp; Объект класса String можно получить используя двойные кавычки;}}</li><li>{{c21::&nbsp; &nbsp; Можно использовать оператор + для конкатенации строк;}}</li><li>{{c21::&nbsp; &nbsp; Любой ссылочный или примитивный тип можно привести к строке.}}</li><li>{{c21::&nbsp; &nbsp; Начиная с Java 7 строки можно использовать в конструкции switch.}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "LyqCx!iGUR", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ul><li>возможен пул строк</li><li>Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения.&nbsp;</li><li>Потокобезопасность.</li><li>Строки используются classloader и неизменность обеспечивает правильность загрузки класса.</li></ul>", 
                "0186.&nbsp;Почему String неизменяемый и финализированный класс?", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::возможен пул строк}}</li><li>...</li><li>...</li><li>...</li></ul>", 
                "<ul><li>возможен пул строк</li><li>{{c2::Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения.&nbsp;}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>...</li><li>Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения.&nbsp;</li><li>{{c3::Потокобезопасность.}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>...</li><li>Потокобезопасность.</li><li>{{c4::Строки используются classloader и неизменность обеспечивает правильность загрузки класса.}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::возможен пул строк}}</li><li>{{c21::Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения.&nbsp;}}</li><li>{{c21::Потокобезопасность.}}</li><li>{{c21::Строки используются classloader и неизменность обеспечивает правильность загрузки класса.}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "og>yW4&Crz", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0187.&nbsp;Почему char[] предпочтительнее String для хранения пароля?", 
                "С момента создания строка остаётся в пуле, до тех пор пока не будет удалена сборщиком мусора. Поэтому, даже после окончания использования пароля, он некоторое время продолжает оставаться доступным в памяти и способа избежать этого не существует. Это представляет определённый риск для безопасности, поскольку кто-либо, имеющий доступ к памяти сможет найти пароль в виде текста. В случае использования массива символов для хранения пароля имеется возможность очистить его сразу по окончанию работы с паролем, позволяя избежать риска безопасности, свойственного строке."
            ], 
            "flags": 0, 
            "guid": "k%,e*Q`ECO", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0188.&nbsp;Почему строка является популярным ключом в HashMap в Java?", 
                "Поскольку строки неизменяемы, их хэш код вычисляется и кэшируется в момент создания, не требуя повторного пересчета при дальнейшем использовании. Поэтому в качестве ключа HashMap они будут обрабатываться быстрее."
            ], 
            "flags": 0, 
            "guid": "s{u:wMvfi4", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0189.&nbsp;Что делает метод intern() в классе String?", 
                "Метод intern() используется для сохранения строки в пуле строк или получения ссылки, если такая строка уже находится в пуле."
            ], 
            "flags": 0, 
            "guid": "NTGDgA68`n", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0190.&nbsp;Можно ли использовать строки в конструкции switch?", 
                "Да, начиная с Java 7."
            ], 
            "flags": 0, 
            "guid": "I9*gg::V,q", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><div><ol><li>&nbsp; &nbsp; участвующие строки чувствительны к регистру;</li><li>&nbsp; &nbsp; используется метод equals() для сравнения полученного значения со значениями case, поэтому во избежание NullPointerException стоит предусмотреть проверку на null.</li><li>&nbsp; &nbsp; согласно документации Java 7, для строк в switch, компилятор Java формирует более эффективный байткод для строк в конструкции switch, чем для сцепленных условий if-else.</li></ol></div></div>", 
                "0191. Особенности использования&nbsp;строки в конструкции switch", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::&nbsp; &nbsp; участвующие строки чувствительны к регистру;}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>&nbsp; &nbsp; участвующие строки чувствительны к регистру;</li><li>{{c2::&nbsp; &nbsp; используется метод equals() для сравнения полученного значения со значениями case, поэтому во избежание NullPointerException стоит предусмотреть проверку на null.}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>&nbsp; &nbsp; используется метод equals() для сравнения полученного значения со значениями case, поэтому во избежание NullPointerException стоит предусмотреть проверку на null.</li><li>{{c3::&nbsp; &nbsp; согласно документации Java 7, для строк в switch, компилятор Java формирует более эффективный байткод для строк в конструкции switch, чем для сцепленных условий if-else.}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::&nbsp; &nbsp; участвующие строки чувствительны к регистру;}}</li><li>{{c21::&nbsp; &nbsp; используется метод equals() для сравнения полученного значения со значениями case, поэтому во избежание NullPointerException стоит предусмотреть проверку на null.}}</li><li>{{c21::&nbsp; &nbsp; согласно документации Java 7, для строк в switch, компилятор Java формирует более эффективный байткод для строк в конструкции switch, чем для сцепленных условий if-else.}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "N$qcbj:m*<", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>Класс String является неизменяемым (immutable) - модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.</li><li>Класс StringBuilder&nbsp;изменяемый - использовать StringBuffer следует тогда, когда необходимо часто модифицировать содержимое.&nbsp;</li><li>Класс StringBuffer&nbsp;&nbsp;был добавлен в Java 5 и он во всем идентичен классу StringBuilder за исключением того, что он &nbsp;синхронизирован (потокобезопасен) и при этом его методы выполняются значительно медленней.</li><li>StringBuilder и&nbsp;StringBuffer имеют буферную память, которая равна 1,5 размера теста + 1 символ.</li></ol></div><div><br /></div>", 
                "0192. Какая основная разница между String, StringBuffer, StringBuilder?", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::Класс String является неизменяемым (immutable) - модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>Класс String является неизменяемым (immutable) - модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.</li><li>{{c2::Класс StringBuilder&nbsp;изменяемый - использовать StringBuffer следует тогда, когда необходимо часто модифицировать содержимое.&nbsp;}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>Класс StringBuilder&nbsp;изменяемый - использовать StringBuffer следует тогда, когда необходимо часто модифицировать содержимое.&nbsp;</li><li>{{c3::Класс StringBuffer&nbsp;&nbsp;был добавлен в Java 5 и он во всем идентичен классу StringBuilder за исключением того, что он &nbsp;синхронизирован (потокобезопасен) и при этом его методы выполняются значительно медленней.}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>Класс StringBuffer&nbsp;&nbsp;был добавлен в Java 5 и он во всем идентичен классу StringBuilder за исключением того, что он &nbsp;синхронизирован (потокобезопасен) и при этом его методы выполняются значительно медленней.</li><li>{{c4::StringBuilder и&nbsp;StringBuffer имеют буферную память, которая равна 1,5 размера теста + 1 символ.}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::Класс String является неизменяемым (immutable) - модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.}}</li><li>{{c21::Класс StringBuilder&nbsp;изменяемый - использовать StringBuffer следует тогда, когда необходимо часто модифицировать содержимое.&nbsp;}}</li><li>{{c21::Класс StringBuffer&nbsp;&nbsp;был добавлен в Java 5 и он во всем идентичен классу StringBuilder за исключением того, что он &nbsp;синхронизирован (потокобезопасен) и при этом его методы выполняются значительно медленней.}}</li><li>{{c21::StringBuilder и&nbsp;StringBuffer имеют буферную память, которая равна 1,5 размера теста + 1 символ.}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "mo>KaAx}On", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0193.&nbsp;Как сравнить две строки в Java и/или отсортировать их?", 
                "Класс String наследует интерфейс Comparable и имеет два варианта метода compareTo()"
            ], 
            "flags": 0, 
            "guid": "g15(R062Df", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ul><li>compareTo(String anotherString) сравнивает объект String с полученным аргументом String лексикографически. Если текущая строка предшествует полученной строке, метод возвращает отрицательное значение типа integer, и если строка следует за полученным аргументом, то возвращает положительное значение integer. Если метод возвращает 0, значит строка имеет то же значение, в таком случае метод equals(String str) так же вернет true.</li><li>compareToIgnoreCase(String str): этот метод подобен предыдущему, за исключением того, что он игнорирует регистр символов. Он использует CASE_INSENSITIVE_ORDER Comparator для регистронезависимого сравнения.&nbsp;</li></ul></div>", 
                "0194. Расскажите о методе&nbsp;compareTo() класса String", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::compareTo(String anotherString) сравнивает объект String с полученным аргументом String лексикографически. Если текущая строка предшествует полученной строке, метод возвращает отрицательное значение типа integer, и если строка следует за полученным аргументом, то возвращает положительное значение integer. Если метод возвращает 0, значит строка имеет то же значение, в таком случае метод equals(String str) так же вернет true.}}</li><li>...</li></ul>", 
                "<ul><li>compareTo(String anotherString) сравнивает объект String с полученным аргументом String лексикографически. Если текущая строка предшествует полученной строке, метод возвращает отрицательное значение типа integer, и если строка следует за полученным аргументом, то возвращает положительное значение integer. Если метод возвращает 0, значит строка имеет то же значение, в таком случае метод equals(String str) так же вернет true.</li><li>{{c2::compareToIgnoreCase(String str): этот метод подобен предыдущему, за исключением того, что он игнорирует регистр символов. Он использует CASE_INSENSITIVE_ORDER Comparator для регистронезависимого сравнения.&nbsp;}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::compareTo(String anotherString) сравнивает объект String с полученным аргументом String лексикографически. Если текущая строка предшествует полученной строке, метод возвращает отрицательное значение типа integer, и если строка следует за полученным аргументом, то возвращает положительное значение integer. Если метод возвращает 0, значит строка имеет то же значение, в таком случае метод equals(String str) так же вернет true.}}</li><li>{{c21::compareToIgnoreCase(String str): этот метод подобен предыдущему, за исключением того, что он игнорирует регистр символов. Он использует CASE_INSENSITIVE_ORDER Comparator для регистронезависимого сравнения.&nbsp;}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "J4A*Z6Dxgu", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0195.&nbsp;Предложите алгоритм преобразования строки в символ", 
                "<div>Проверить, возможно ли преобразование (строка состоит из одного символа), и преобразовать строку в символ с помощью charAt(0) если это возможно.</div><div><br /></div><div><div><center><table><tbody><tr><td><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">String str <span style=\"color: #666666\">=</span> <span style=\"color: #BA2121\">\"a\"</span><span style=\"color: #666666\">;</span>\n<span style=\"color: #008000; font-weight: bold\">if</span> <span style=\"color: #666666\">(</span>str<span style=\"color: #666666\">.</span><span style=\"color: #7D9029\">length</span><span style=\"color: #666666\">()</span> <span style=\"color: #666666\">==</span> <span style=\"color: #666666\">1){</span>\n     <span style=\"color: #B00040\">char</span> c <span style=\"color: #666666\">=</span> str<span style=\"color: #666666\">.</span><span style=\"color: #7D9029\">charAt</span><span style=\"color: #666666\">(0);</span>\n<span style=\"color: #666666\">}</span>\n</pre></div>\n</td></tr></tbody></table></center><br /></div></div>"
            ], 
            "flags": 0, 
            "guid": "lO|tx1f]*r", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0196.&nbsp;Как преобразовать строку в массив байтов и обратно?", 
                "<div><center><table><tbody><tr><td><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">String str <span style=\"color: #666666\">=</span> <span style=\"color: #BA2121\">\"string\"</span><span style=\"color: #666666\">;</span>\n<span style=\"color: #B00040\">byte</span><span style=\"color: #666666\">[]</span> byteArr <span style=\"color: #666666\">=</span> str<span style=\"color: #666666\">.</span><span style=\"color: #7D9029\">getBytes</span><span style=\"color: #666666\">();</span>\nString str1 <span style=\"color: #666666\">=</span> <span style=\"color: #008000; font-weight: bold\">new</span> String<span style=\"color: #666666\">(</span>byteArr<span style=\"color: #666666\">);</span>\n</pre></div>\n</td></tr></tbody></table></center><br /></div>"
            ], 
            "flags": 0, 
            "guid": "kf>U5`J#H<", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0095.&nbsp;единственное ограничение на набор интерфейсов, которые может реализовывать класс", 
                "Если попытаться объявить класс, реализующий несколько интерфейсов в которых есть методы с одинаковой сигнатурой но различными возвращаемыми типами - возникнет ошибка компиляции."
            ], 
            "flags": 0, 
            "guid": "fW6M4.pz**", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0024_1.&nbsp;Принцип подстановки Барбары Лисков", 
                "<div>Наследующий класс должен дополнять, а не замещать поведение базового класса.</div><div>Формально звучит как \"Пусть q(x) является свойством верным относительно объектов x некоторого типа T. Тогда q(y) также должно быть верным для объектов y типа S, где S является подтипом типа T\"</div>"
            ], 
            "flags": 0, 
            "guid": "qI?Cb{IQi`", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>Легкость вычисления адреса элемента массива по его индексу</li><li>Одинаковое время доступа к любому элементу массива</li><li>Малый размер – состоят только из информационного поля</li><li>Возможность хранения отсортированных данных и поиск информации в них</li><li>Для динамических массивов: быстрая работа с концом массива (добавление и удаление)</li></ol></div>", 
                "0091_8.&nbsp;Достоинства массивов", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::Легкость вычисления адреса элемента массива по его индексу}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>Легкость вычисления адреса элемента массива по его индексу</li><li>{{c2::Одинаковое время доступа к любому элементу массива}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>Одинаковое время доступа к любому элементу массива</li><li>{{c3::Малый размер – состоят только из информационного поля}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>Малый размер – состоят только из информационного поля</li><li>{{c4::Возможность хранения отсортированных данных и поиск информации в них}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>Возможность хранения отсортированных данных и поиск информации в них</li><li>{{c5::Для динамических массивов: быстрая работа с концом массива (добавление и удаление)}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::Легкость вычисления адреса элемента массива по его индексу}}</li><li>{{c21::Одинаковое время доступа к любому элементу массива}}</li><li>{{c21::Малый размер – состоят только из информационного поля}}</li><li>{{c21::Возможность хранения отсортированных данных и поиск информации в них}}</li><li>{{c21::Для динамических массивов: быстрая работа с концом массива (добавление и удаление)}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "dCInF<I*Z3", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>Необходимость хранения информации в непрерывном объеме памяти</li><li>Для статического массива – невозможность добавления и удаления элемента</li><li>Угроза выхода за границу массива</li><li>Низкое быстродействие на поиск (для несортированного массива), добавления и удаления элемента</li><li>Дополнительные расходы на на динамические свойства массива</li></ol></div>", 
                "0091_9.&nbsp;Недостатки массивов", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::Необходимость хранения информации в непрерывном объеме памяти}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>Необходимость хранения информации в непрерывном объеме памяти</li><li>{{c2::Для статического массива – невозможность добавления и удаления элемента}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>Для статического массива – невозможность добавления и удаления элемента</li><li>{{c3::Угроза выхода за границу массива}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>Угроза выхода за границу массива</li><li>{{c4::Низкое быстродействие на поиск (для несортированного массива), добавления и удаления элемента}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>Низкое быстродействие на поиск (для несортированного массива), добавления и удаления элемента</li><li>{{c5::Дополнительные расходы на на динамические свойства массива}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::Необходимость хранения информации в непрерывном объеме памяти}}</li><li>{{c21::Для статического массива – невозможность добавления и удаления элемента}}</li><li>{{c21::Угроза выхода за границу массива}}</li><li>{{c21::Низкое быстродействие на поиск (для несортированного массива), добавления и удаления элемента}}</li><li>{{c21::Дополнительные расходы на на динамические свойства массива}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "L=eo%lkob>", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0131_1. Имеет ли локальный класс имя?", 
                "да.&nbsp;Как и простые внутренние классы (<b>Member inner class</b>) локальные классы имеют имена."
            ], 
            "flags": 0, 
            "guid": "l]mRtktOOf", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0131_2. Может ли локальный класс использоваться многократно?", 
                "да, как и простые внутренние классы (<b>Member inner class</b>) локальные классы могут использоваться многократно."
            ], 
            "flags": 0, 
            "guid": "hz&tMYjMb_", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0131_3. Имеют ли локальные классы ссылку на окружающий их экземпляр класса?", 
                "Как и для анонимных классов - только тогда, когда применяются в нестатическом контексте."
            ], 
            "flags": 0, 
            "guid": "sJftEh^Q#3", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0132_1. Анонимный класс - он статический или нет?", 
                "Зависит от контекста где он объявлен. Если в статическом - ведет себя как статический, если в нестатическом - наоборот. В нестатическом контексте появляется ссылка на окружающий его экземпляр.&nbsp;"
            ], 
            "flags": 0, 
            "guid": "BftX`8r=ay", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0027_2. Можно ли char привести к boolean?", 
                "Нет"
            ], 
            "flags": 0, 
            "guid": "y/!~u`^IHd", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ul><li>Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется, чтобы объявления этих исключений были перечислены в throws&nbsp;&nbsp;всех конструкторов класса. Иначе будет ошибка компиляции.&nbsp;</li><li>Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.&nbsp;</li><li>В остальных случаях, взаимодействие с исключениями будет проходить так же как и в любом другом месте. Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.</li></ul>", 
                "0103. Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ul><li>{{c1::Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется, чтобы объявления этих исключений были перечислены в throws&nbsp;&nbsp;всех конструкторов класса. Иначе будет ошибка компиляции.&nbsp;}}</li><li>...</li><li>...</li></ul>", 
                "<ul><li>Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется, чтобы объявления этих исключений были перечислены в throws&nbsp;&nbsp;всех конструкторов класса. Иначе будет ошибка компиляции.&nbsp;</li><li>{{c2::Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.&nbsp;}}</li><li>...</li></ul>", 
                "<ul><li>...</li><li>Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.&nbsp;</li><li>{{c3::В остальных случаях, взаимодействие с исключениями будет проходить так же как и в любом другом месте. Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.}}</li></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul></ul>", 
                "<ul><li>{{c21::Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется, чтобы объявления этих исключений были перечислены в throws&nbsp;&nbsp;всех конструкторов класса. Иначе будет ошибка компиляции.&nbsp;}}</li><li>{{c21::Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.&nbsp;}}</li><li>{{c21::В остальных случаях, взаимодействие с исключениями будет проходить так же как и в любом другом месте. Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.}}</li></ul>"
            ], 
            "flags": 0, 
            "guid": "MDJ4i:/eXX", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ol><li>благодаря каким условиями возможен пулл строк</li><li>сказать про память</li><li>что происходить при создании строки при помощи кавычек</li><li>что происходить при создании строки при помощи new (и что произойдет при вызове метода intern() для этого объекта)</li><li>какой паттерн проектирования реализует пулл строк</li></ol>", 
                "<div>0166_1. План ответа про пулл строк</div>", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::благодаря каким условиями возможен пулл строк}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>благодаря каким условиями возможен пулл строк</li><li>{{c2::сказать про память}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>сказать про память</li><li>{{c3::что происходить при создании строки при помощи кавычек}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>что происходить при создании строки при помощи кавычек</li><li>{{c4::что происходить при создании строки при помощи new (и что произойдет при вызове метода intern() для этого объекта)}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>что происходить при создании строки при помощи new (и что произойдет при вызове метода intern() для этого объекта)</li><li>{{c5::какой паттерн проектирования реализует пулл строк}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::благодаря каким условиями возможен пулл строк}}</li><li>{{c21::сказать про память}}</li><li>{{c21::что происходить при создании строки при помощи кавычек}}</li><li>{{c21::что происходить при создании строки при помощи new (и что произойдет при вызове метода intern() для этого объекта)}}</li><li>{{c21::какой паттерн проектирования реализует пулл строк}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "loUU_yk`3W", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0166_2.&nbsp;благодаря каким условиями возможен пулл строк?", 
                "благодаря неизменяемости строк в Java и реализации идеи интернирования строк"
            ], 
            "flags": 0, 
            "guid": "D0Lt[//+)B", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0166_3. Что можно сказать про использование памяти при использовании пула строк?", 
                "помогает экономить память, но при этом создание строки занимает больше времени;"
            ], 
            "flags": 0, 
            "guid": "k1O%xCQ]ps", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0166_4. что происходит, когда строка создается при помощи кавычек?", 
                "сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка на неё;"
            ], 
            "flags": 0, 
            "guid": "G}!k%K0mUR", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0166_5. что происходит при создании строки при помощи оператора new", 
                "создаётся новый объект String. Затем при помощи метода intern() эту строку можно поместить в пул или же получить из пула ссылку на другой объект String с таким же значением"
            ], 
            "flags": 0, 
            "guid": "t5>+>_.C5!", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0166_6. какой паттерн проектирования реализует пулл строк?", 
                "«Приспособленец» (Flyweight)."
            ], 
            "flags": 0, 
            "guid": "I?#EZ)oVBV", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "0100_1.Какие бывают блоки инициализации", 
                "статические и нестатические"
            ], 
            "flags": 0, 
            "guid": "cq0!7w<rUW", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "100_2. Когда исполняется код в блоках инициализации", 
                "перед инициализацией класса загрузчиком классов или созданием объекта класса с помощью конструктора"
            ], 
            "flags": 0, 
            "guid": "zRzr.D$gsr", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "100_3. В каком порядке выполняются блоки инициализации", 
                "в порядке следования в коде класса"
            ], 
            "flags": 0, 
            "guid": "Fru1yCTeTC", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "100_4. Могут ли блоки инициализации генерировать исключения?", 
                "Нестатический блок инициализации способен генерировать исключения, если их объявления перечислены в throws всех конструкторов класса. В статическом блоке генерация исключения приводит к ошибке компиляции"
            ], 
            "flags": 0, 
            "guid": "bHQBI6B,VB", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "100_5. Можно ли создать блоки инициализации в анонимном классе?&nbsp;", 
                "только в нестатическом"
            ], 
            "flags": 0, 
            "guid": "b/bsSs97m0", 
            "note_model_uuid": "27a73213-a698-11ea-b04e-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "access array element [ ]<br />access object member . (dot operator)", 
                "0026_7. access operators", 
                "", 
                "", 
                "1,0,0 | n,n,n,n", 
                "<div>...</div><div>...</div>", 
                "<div>access array element [ ]</div><div>...</div>", 
                "<div>...</div><div>access object member . (dot operator)</div>", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "", 
                "<div>{{c21::access array element [ ]}}</div><div>{{c21::access object member . (dot operator)}}</div>"
            ], 
            "flags": 0, 
            "guid": "brFb8cTkr9", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<div><ol><li>unary pre-increment ++</li><li>unary pre-decrement --</li><li>unary plus +</li><li>unary minus -&nbsp;</li><li>unary logical NOT !</li><li>unary bitwise NOT ~</li></ol></div>", 
                "0027_8. unary operators", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::unary pre-increment ++}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>unary pre-increment ++</li><li>{{c2::unary pre-decrement --}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>unary pre-decrement --</li><li>{{c3::unary plus +}}</li><li>...</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>unary plus +</li><li>{{c4::unary minus -&nbsp;}}</li><li>...</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>unary minus -&nbsp;</li><li>{{c5::unary logical NOT !}}</li><li>...</li></ol>", 
                "<ol><li>...</li><li>...</li><li>...</li><li>...</li><li>unary logical NOT !</li><li>{{c6::unary bitwise NOT ~}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::unary pre-increment ++}}</li><li>{{c21::unary pre-decrement --}}</li><li>{{c21::unary plus +}}</li><li>{{c21::unary minus -&nbsp;}}</li><li>{{c21::unary logical NOT !}}</li><li>{{c21::unary bitwise NOT ~}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "N>D>R@F$~e", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }, 
        {
            "__type__": "Note", 
            "data": "", 
            "fields": [
                "<ol><li>+ and&nbsp;-</li><li>string concatenation +</li></ol>", 
                "0026_9. additive operators", 
                "", 
                "", 
                "1,1,0 | n,n,n,n", 
                "<ol><li>{{c1::+ and&nbsp;-}}</li><li>...</li></ol>", 
                "<ol><li>+ and&nbsp;-</li><li>{{c2::string concatenation +}}</li></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol></ol>", 
                "<ol><li>{{c21::+ and&nbsp;-}}</li><li>{{c21::string concatenation +}}</li></ol>"
            ], 
            "flags": 0, 
            "guid": "r.EUZGEnG.", 
            "note_model_uuid": "27a75936-a698-11ea-a217-005056c00008", 
            "tags": []
        }
    ]
}